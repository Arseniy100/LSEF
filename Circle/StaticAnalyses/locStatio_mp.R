# 
# =Generate the true local spectra 
# =Generate the truth and the ensm -- either with PMT or taking an external KF CVMs
# =Create the spectral bands of the multi-scale bandpass filter.
# =E2B: Apply the multi-scale bandpass filter to the ensm members.
# =B2S: From band variances, restore the whole local spectrum (at all grid points indep-ly) using LSM
# =Compare the estimated spectra w the true (specified) ones. The same with cvfs.
# =From the local spectra of the LSM, compute W and an estm the true B: B_LSM=W*W^T.
# =Analysis: compare B=W_SLM* (W_SLM)^T   with   S_lcz  in computing the 
#           deterministic anls x_a. Assess the accuracy of x_a as compared w truth.
#
# ----------------
# With  B2S_SVshape, first, run with  CALIBRATE = T  and n_repl=50  
# to calc the shape of the mean spectrum (the true median shape is the default).
# Then, switch to  CALIBRATE = F
# (otherwise, the true spectral shape is used)
# 
# With  B2S_NN:
#  if LEARN = T, run the code with n_repl=50000 to estm weights of the neural network.
#  if LEARN = F, read NN from a file
#----------------------------------------------------------
# To run this script, set up the following key parameters:
# (1) LEARN: if T, generate the truth & train the NN
#            if F, run & verify analyses
#            
# (2) B_source  --  specifies the source of input spatial covariances:
#   ="internal_PMT" -- the truth and the ensm are generated by the built-in Parametric 
#                     Locally Stationary Convolution Molde of Truth (PMT)
#   ="external_KF" -- KF's B matrices (or spat-ave cvfs) are read from a file and used to generate the truth and the ensm
#   ="external_EnKF" -- EnKF's ensm perturbations EE  (or spat-ave cvfs) are read from a file and used 
#                       fit LSM and, with the fitted LSM's B, to generate the truth and the final ensm
#                       
# The way KF/EnKF output data are used here depends on the prm  B_source_KF_EnKF_spat_ave:
# 
# (3) B_source_KF_EnKF_spat_ave:
#  if B_source_KF_EnKF_spat_ave=T, then STATIO space-averaged cvfs are used 
#    (computed at a number of time instants during KF/EnKF filtering)
#    --- both for learning and computing verifying analyses.
#    
#  if B_source_KF_EnKF_spat_ave=F, then full KF cvms or EnKF's EE are used as follows:
#    (1) If LEARN=T, LSM is fitted at each i_repl=1:n_repl  
#                    and the resulting local spectra b_LSM and the resp. cvm B_LSM are used as the TRUTH
#    (2) If LEARN=F,  KF:  B_KF is used at each i_repl to generate the truth, ensm, obs.
#                     EnKF: not applicable
#                     LSM is fitted for B_LSM to be used in the anls only.
#     NB: B_source_KF_EnKF_spat_ave = T is the best choice.
#  NB:
#  If B_source == "internal_PMT", then set up all the prms of the PMT: kappa, NSL, the 
#                 local-spectrum estimation method (B2S_method) etc.
#  If B_source == "external_KF" or "external_EnKF", make sure the respective input files are there
#     (copied from the LSEF (Filtering) folder).
#  
# (2) LEARN -- set TRUE if the NN is to be trained and
#                  FALSE if a pre-trained NN is to be used
# (3) CALIBRATE -- set FALSE unless you wish to calc the mean shape of the local spectrum 
#
# nx -- grid size
# ne -- ensm size
#
#--------------
# Notation:
# 
# Averaging: suffixes
# _Ms -- spatial sample mean
# _Me -- ensm sample mean
# _Mb -- sample mean over the bands
# _Mw -- mean over the wavenumbers
# _Mt -- mean over the True model
# _Mr -- mean over the replicates of the whole scheme
# _MB - mean over the Bootstrap sample
# 
# _A* - mean abs
# _AE - MAE
# _AD - Mean abs deviation
# _ME - mean error (bias)
# _V* - variances (understood here always as Ex(x^2), i.e. w/o subtract.the mean)
# _S* - sums
# _D* - st.devs
# _R* - RMSs
# _RE - RMSE
# _Q - mean squared
# _QE - mean squared Error
# _DE - st.dev. Error
# 
# _T - theoretical moment (eg _TD - theoretical SD)
# 
# _O* - smoothing
# 
# _MA* - mean-abs value
# ---
# band - pass band
# 
# M Tsy 2020, 2021, 2022, 2023
#*****************************************************
library(attempt)
library(plot3D)
library(Matrix)
library(pracma)
library(nnls)
library(stats)
library(mixmeta)
library(moments)
library(torch)

source('./Functions/Anls/gen_obs.R')
source('./Functions/Anls/lin_determ_anls.R')

source('./Functions/B2S/AEV_loss.R')
source('./Functions/B2S/L2_loss_custom.R')
source('./Functions/B2S/B2S_lines.R')
source('./Functions/B2S/B2S_monot.R')
source('./Functions/B2S/B2S_param.R')
source('./Functions/B2S/B2S_prmFitAnlsErr.R')
source('./Functions/B2S/B2S_shape.R')
source('./Functions/B2S/B2S_NN.R')
source('./Functions/B2S/B2S_SVshape.R')
source('./Functions/B2S/AEV_deviance_S1.R')
source('./Functions/B2S/AEV_deviance_S1_sample.R')
source('./Functions/B2S/bmeanBand_intpl.R')
source('./Functions/B2S/spe_misfitAnlsErr.R')
source('./Functions/B2S/V_prm_misfit.R')
source('./Functions/B2S/varfu.R')
source('./Functions/B2S/NmonotSpec.R')

source('./Functions/B2S/TransformSpectrum.R')

source('./Functions/CreateBands/CreateExpqBands.R')
source('./Functions/CreateBands/Omega_SVD.R')
source('./Functions/CreateBands/tranfuBandpassExpq.R')

source('./Functions/E2B/E2B.R')
source('./Functions/E2B/band_lbmean.R')

source('./Functions/fitLSM/fit_LSM.R')

source('./Functions/LinAlgebra/BshiftMx_S1.R')
source('./Functions/LinAlgebra/Cov2VarCor.R')
source('./Functions/LinAlgebra/mult_squareMx_ADAT.R')
source('./Functions/LinAlgebra/symm_cvm_row.R')
source('./Functions/LinAlgebra/symm_pd_mx_sqrt.R')
source('./Functions/LinAlgebra/Superdiagonals.R')

source('./Functions/LSM/Sigma2WB.R')
source('./Functions/LSM/createNstatioWSigma_S1.R')

source('./Functions/RandProc/create_crm_S1.R')
source('./Functions/RandProc/crfs_isotr.R')
source('./Functions/RandProc/CvfSpeTransfPair_d1_3.R')
source('./Functions/RandProc/gen_homProc_fromSpectrum_S1.R')
source('./Functions/RandProc/SpatAveCrf_S1.R')
source('./Functions/RandProc/spec_S1_analyt.R')
source("./Functions/RandProc/ThreePointSmoo_S1.R")
source('./Functions/RandProc/ThreePointSmoo_segment.R')
source("./Functions/RandProc/tranfuSmoo_lowpass_dscrWvns.R")

source('./Functions/Stats/Ex2_ExAbs.R')
source('./Functions/Stats/md2sd.R')

source("./Functions/Varia/bisection.R")
source('./Functions/Varia/cyclic_shift_S1.R')
source('./Functions/Varia/d_norms.R')
source('./Functions/Varia/evalFuScaledArg.R')
source('./Functions/Varia/fitScaleMagn.R')
source('./Functions/Varia/LinIntpl.R')
source("./Functions/Varia/logistic.R")
source('./Functions/Varia/monotSmooFit.R')

#--------------------------------------------------------------
# external prms

LEARN = F                    
B_source = "internal_PMT" # "internal_PMT"  "external_KF"  "external_EnKF" -- CVMs to generate truth & ensm                 or 
B_source_KF_EnKF_spat_ave = T # if T: KF/EnKS's: spat-ave cvfs are handled & global (statio) spectra are used.
                              # if F,            full CVMs are use to fit LSM & use its loc.spectra to gen.training sample
nx = 120; nmax=floor(nx/2); dx=2*pi/nx # nx sh.be a highly composite number (for fft)
ne = 10  # ensm size
kappa = 2 # nstatio strength (NSS); =1...4;  kappa=1: statio; kappa=2 nrm
NSL = 3 # Non-stationarity Length (relative to L_xi). NSL=3 nrm

J=6 ; nband=J # nu of bands (6 nrm)
B2S_method = "NN" # SVshape NN LINSHAPE LINES PARAM 
NN_pretrained = T # set =T if a pretrained NN is available 

# Bands tuning
bandWidth_mult = 1 # multiplier for all bands' halfwidths (default 1)
nc2_mult = 1 # multiplier for nc2 (2nd band's tranfu-maximum wvn-location) (default 1)

# Hybridization of mean/median cvm with S_lcz

static_B_mean_median = 2 # static B =1: mean, =2: ``median'' (opt 2!)
w_ensm_hybr = 0.5 # weight in  B_hybr = w_ensm_hybr*S_lcz + (1-w_ensm_hybr)*B_static (opt 0.5)

# PMT

SDxi_med = 5       # median of the statio fld S(x)  
SDxi_add = SDxi_med /100 # minimal SDxi
lambda_med = dx*6 # dx*1 dx*3  # median lambda(x): the desired median length scale 
lambda_add = dx/2 # /10# dx/3    # minimal lambda(x): accounts for the grid resolution
Lambda_preTransform = lambda_med * NSL # pre-transform (statio) len scale
gamma_add = 1.0      # minimal gamma(x): avoid too low gamma ==> weird crf, non-convergent spectrum
gamma_med = 1.5    # S1: 3.0 yields almost AR2 cvf (S2: gamma=3.1 yields AR2), =4: S2 default
Gamma_preTransform   = 3 # for lambda & gamma chi flds

# Fit a time-mean spectral shape to the local spectrum -- prms

moments = "012" # : use "01" , "12" , "012"
a_max_times = 5e3 # max deviation of the scale multiplier  a  from 1 in times 
w_a_fg = 0.0  #  weight of the ||a-1||^2 weak constraint in fitScaleMagn

# BANDS' prms

q_tranfu=3 # tranfu=exp(-|(n-nc)/halfwidth|^q_tranfu)) 2, 3 nrm
halfwidth_min=bandWidth_mult * nx/50 # 360:/50
nc2=                nc2_mult * nx/40           # 360:/40                 
halfwidth_max=bandWidth_mult * nx/5  # 360:/5 

if(nx == 60){
  halfwidth_min=bandWidth_mult * 2.5 # 360:/50
  nc2=                nc2_mult * 4.5           # 360:/40                 
  halfwidth_max=bandWidth_mult * 20  # 360:/5 
  moments = "01"
}

# B2S prms

if(B2S_method == "NN" | LEARN == T){
  loss_type = "L2"  # "L2"  "AEV"
  
  if(loss_type == "AEV"){
    TransformSpectrum_type_y = "sqrt" # "none" "log" "sqrt" "pow" "RELU"
    TransformSpectrum_pow_y = 1 # for "pow" only
  }else{        # L2 loss
    TransformSpectrum_type_y = "sqrt" # "none" "log" "sqrt" "pow" "RELU" -- sqrt good
    TransformSpectrum_pow_y = 1/sqrt(8) # for "pow"
  }
  TransformSpectrum_type_x = "sqrt" # "none" "log" "sqrt" "pow"  "RELU" -- none or sqrt 
  TransformSpectrum_pow_x = 1/sqrt(8)  # for "pow":  1/sqrt(2)   1/sqrt(8) 
}
if(B2S_method == "SVshape" | B2S_method == "MONOT"){
   nSV_discard = 0 # discard trailing SV to filter sampling noise
}
if(B2S_method == "LINES" | B2S_method == "LINSHAPE" | B2S_method == "PARAM" 
   | B2S_method == "MONOT"){
  B2S_bbc = TRUE # FALSE TRUE apply bootstrap bias correc (bbc) B2S_lines (T/F)
  niter_bbc = 3 # number of bbc iterations
  correc_bbc = "mult" # "add" or "mult" - method of bbc-correction
} 
if(B2S_method == "PARAM" ){
  na=21
  a_search_times = 2.5
  eps_V_sd = 0.2 # portion of mean TSD(band_Ve) used as an additive rglrzr 
  eps_smoo=0.25 # rel strength of penalty on Smoothness of errors in V_j
  w_a_rglrz = 10 # weight, penalize deviations of  a  from  a_fg=1
}

rel_W_threshold = 1e-5 # threshold W
glob_loc_thresholding = 1

BOOTENS = F # T F bootstrap the ensm?
nB = 21 # Bootstrap-sample size. ODD if median is to be within the sample

if(LEARN){                 # train the NN
  message("NN learning mode")
  message("(Skip B2S & ANLS)")
  epochs = 200 # 50-200 epochs optim with 2500 minibatch size
  minibatch_size = 2500  # 2500 optim with 30-40 epochs
  
}                          # Read a pre-trained NN from a file 
if(B2S_method == "NN"){
  if(!LEARN | ( B_source != "internal_PMT" & NN_pretrained )){ 
    NN = torch_load("NN.pt")
  }
}

CALIBRATE = F # if TRUE, calc only the n_repl-averaged b_shape_estm[n]
if(CALIBRATE){
  message("CALIBRATION mode: estm var_xi_mean, crf_xi_mean, b_mean")
  message("(Skip B2S & ANLS)")
}

obs_per_grid_cell = 0.5  # 1 obs per obs_per_grid_cell (on average) (0.5 or 1 or 2)
n_obs=round(nx*obs_per_grid_cell)
sd_obs_rel_FG=1 # 1 0.5
obs_err_variance = (SDxi_med * sd_obs_rel_FG)^2 # NB: SDxi_med^2 is not exactly the mean Var(xi)
repeated_obs_location = T # F or T allow several obs to be located at the same grid point?
uniform_obs_cover = F # F nrm

seed = 154
# seed=seed+10
set.seed(seed)  # fix start seed

n_repl = 50 # only for verif anls (nx=120: set =200). LEARN=T & "internal_PMT" ==> n_repl is set just below 

message("n_repl=", n_repl)

# Plotting
l_CRL_COV_plots = 1 # 1 - spat crl, 2 - covar

#--------------------------------------------------------------
# derived and minor prms, synonyms

# constants

Rem=6.37*10^6 # m
Rekm=Rem / 10^3 # km

# Grids

dx_km = dx* Rekm
xx=c(0:(nx-1))* dx
xx_km = xx * Rekm
ii_x = c(1:nx)
ii_n = c(1:nx)
nn_half = c(0:nmax)
n0 = 0           # prm spec mdl b[n]=V/(1+(lambda*(n+n0))^gamma), =0: S2 default
nn_half_pn0 = nn_half + n0
nn = c(0:(nx-1))

# Lcz fu type

crftype = "AR2" # "exp", "AR2", "AR3", "Gau", "Cauchy", "ecos", "Bessel", "Matern"

# Bands' tranfu shape: rectangular?

rectang = FALSE # FALSE TRUE rectangular shape of passbands' transfer functions

# True spectra: derived prms

SDxi_mult  = SDxi_med - SDxi_add
lambda_mult = lambda_med - lambda_add 
gamma_mult =  gamma_med - gamma_add

n1=1
lognp1 = log(c(0:nmax) + n1) 

# ratio MD (or MAD - mean abs dev from mean - not median!) to SD for chi^2 distr
md2sd_chi2 = md2sd(distrib = "chi2", nu=ne-1)

# scipen: favors sci notation (1e5) over fixed notation (100000)

options(scipen = -1)   

# R plotting margins

par(mar=c(5.1, 4.1, 4.1, 4.1))

# General

n=nx
nmaxp1 = nmax +1
nmaxp2 = nmax +2
ns = nmaxp1
nmaxm1 = nmax -1

Jm1 = J-1
Jm2 = J-2

#--------------------------------------------------------------
# Checks

if(nB %% 2 == 0){
  message("nB=", nB, " -- should be ODD")
  stop("Change nB")
}

if(static_B_mean_median == 1 & !exists("B_mean") & CALIBRATE==FALSE){
  message("static_B_mean_median=1 and B_mean is not yet estimated")
  stop("Run CALIBRATE")
}

#--------------------------------------------------------------
# Specify L_lcz

if(ne < 10) L_lcz = 1.5* lambda_med/2  # lcz length scale, rad.
if(ne < 20 & ne >= 10) L_lcz = 2.0* lambda_med/2  # lcz length scale, rad.
if(ne >= 20 & ne < 40) L_lcz = 3 * lambda_med/2  # lcz length scale, rad.
if(ne >= 40 & ne < 80) L_lcz = 3.5 * lambda_med/2  # lcz length scale, rad.
if(ne >= 80) L_lcz = 4.5 * lambda_med/2  # lcz length scale, rad.

C_lcz = create_crm_S1(nx, L_lcz, crftype, nu=1)

# End of the SETUP section
#--------------------------------------------------------------
#--------------------------------------------------------------
# Prepare the 3 sources of input info: PMT, KF, EnKF

if(B_source == "internal_PMT"){ # PMT: Median and pre-transform W, B, Sigma, spectra
  #-------------------------
  # Pre-transform (i.e. chi fields') spectrum.
  #    b(n) = c/( 1 + (Lambda_median * (n+n0))^Gamma_preTransform ) 
  # c  is calculated to ensure that 
  #    Var(chi) = \sum{all n on the circle} b[n] =1

  b_preTransform = c(1:nx) # init, for lamdba and gamma flds
  b_preTransform[1:nmaxp1] = 1/( 1 + (Lambda_preTransform * nn_half_pn0[])^Gamma_preTransform )
  b_preTransform[nmaxp2:nx] = rev(b_preTransform[2:nmax])
  v = sum(b_preTransform)
  b_preTransform = b_preTransform / v 
  
  # sum(b_preTransform)
  # plot(b_preTransform)
  
  # implied preTransform fld cvf 
  
  ccvf_preTransform = fft(b_preTransform, inverse = TRUE)
  # max(abs(Im(ccvf_preTransform)))
  ccvf_preTransform=Re(ccvf_preTransform)
  
  # mn=min(ccvf_preTransform)
  # mx=max(ccvf_preTransform)
  # plot(ccvf_preTransform, type="p", ylim=c(0,mx))
  
  # nx_plot=nx/2
  # mx=max(ccvf_preTransform[1:nx_plot])
  # mn=min(ccvf_preTransform[1:nx_plot])
  # plot(x=xx_km[1:nx_plot], y=ccvf_preTransform[1:nx_plot], type="p", ylim=c(mn,mx),
  #      main="Cvf of preTransform fields chi_*", xaxs="i", yaxs="i")
  # abline(h=0)
  #--------------------------
  # Median spectrum
  #    b(n) = c/( 1 + (lambda_med * (n+n0))^gamma_med ) 
  # c  is calculated to ensure that 
  #    Var(chi) = \sum{all n on the circle} b[n] = SDxi_med^2
  
  b_median_1D = c(1:nx) # init
  b_median_1D[1:nmaxp1] = 1/( 1 + (lambda_med * nn_half_pn0[])^gamma_med )
  b_median_1D[nmaxp2:nx] = rev(b_median_1D[2:nmax])
  v = sum(b_median_1D)
  b_median_1D_nrm = b_median_1D / v
  b_median_1D = b_median_1D_nrm * SDxi_med^2
  
  plot(x=log(nn_half+n1), y=log(b_preTransform[1:nmaxp1]/b_preTransform[1]),
       main="Shape of \n log(preTransform spectrum) (circ) \n log(median spectrum) (line) ")#, xaxs="i", yaxs="i")
  lines(x=log(nn_half+n1), y=log(b_median_1D[1:nmaxp1]/b_median_1D[1]))  
  
  # implied median fld cvf 
  
  ccvf_med_mean = Re( fft(b_median_1D, inverse = TRUE) )
  
  var_med = ccvf_med_mean[1]
  ccrf_med_mean = ccvf_med_mean / ccvf_med_mean[1]
  
  nx_plot=nx/2
  mx=max(ccvf_med_mean[1:nx_plot] / ccvf_med_mean[1], ccvf_preTransform[1:nx_plot] / ccvf_preTransform[1])
  mn=min(ccvf_med_mean[1:nx_plot] / ccvf_med_mean[1], ccvf_preTransform[1:nx_plot] / ccvf_preTransform[1])
  
  plot(x=xx_km[1:nx_plot], y=ccvf_med_mean[1:nx_plot] / ccvf_med_mean[1], type="p", ylim=c(mn,mx),
       main="Crf of median fields (circ), \n preTransform (chi) flds (line)", 
       xaxs="i", yaxs="i")
  lines(x=xx_km[1:nx_plot], y=ccvf_preTransform[1:nx_plot] / ccvf_preTransform[1])
  abline(h=0) 
  
  #------------
  # Sigma_median, B_median
  # NB: Sigma[ix,n+1] etc.
  
  L_xi_median = lambda_med/2 # for plotting
  
  b_median_T = matrix(b_median_1D, nrow = nx, ncol = nx)
  b_median = t(b_median_T)
  Sigma_median = sqrt(b_median)
  
  WB_median = Sigma2WB(Sigma_median)
  
  W_median = WB_median$W
  B_median = WB_median$B

  true_spectra_available = TRUE
  
  # Training sample prms
  
  if(LEARN){
    LrnSampleThinningStride_prelim = lambda_med * NSL / dx /2 # meshes, prelim
    LrnSampleThinningStride = nx / (nx %/% LrnSampleThinningStride_prelim)
    LrnPointsPerRepl = nx  / LrnSampleThinningStride
    if(LrnSampleThinningStride < 2) LrnSampleThinningStride = 2
    if(LrnSampleThinningStride > nmax) LrnSampleThinningStride = nmax
    
    # select n_repl if LEARN=T
    # Ensure that both  k=LrnPointsPerRepl  and   m=minibatch_size  are divisors of  n_train 
    
    n_train_desired = 1e5
    km = LrnPointsPerRepl *minibatch_size # k=LrnPointsPerRepl,  m=minibatch_size
    n_train = ceiling(n_train_desired / km) * km
    n_repl = n_train / LrnPointsPerRepl
  }
  
}else{   # non-PMT input: KF or EnKF data
#--------------------------------------------------------------
# Read  B or EE from an external source: KF or EnKF.
# B will be used to compute the truth and the ensm
# If, in addition, LEARN=T, then LOCAL SPECTRA  b_true  are needed.
# This are estimated in the loop over n_repl below --- by fitting LSM

  if(B_source == "external_KF"){
    load(file="KF_data.RData", verbose = TRUE) # loads  KF_data
    
    # KF_data = list(B_KF=B_KF, B_clim_long, b_shape, spat_ave_cvfs)
    
    B_KF                  = KF_data$B_KF          # [1:nx, 1:nx, 1:ntime_B_store]
    B_clim_KF_EnKF        = KF_data$B_clim        # [1:nx, 1:nx]
    b_shape_KF_EnKF       = KF_data$b_shape       # [1:nmaxp1]
    spat_ave_cvfs_KF_EnKF = KF_data$spat_ave_cvfs # [1:nx, 1:ntime_filter]
    
    
  }else if(B_source == "external_EnKF"){
    load(file="EnKF_data.RData", verbose = TRUE) # loads  EnKF_data
    
    # EnKF_data = list(EE, S_mean, b_shape_EnKF, spat_ave_cvfs_EnKF)
    
    EE                    = EnKF_data$EE               # [1:nx, 1:nx, 1:ntime_EE_store]
    B_clim_KF_EnKF        = EnKF_data$S_mean             # [1:nx, 1:nx]
    b_shape_KF_EnKF       = EnKF_data$b_shape_EnKF       # [1:nmaxp1]
    spat_ave_cvfs_KF_EnKF = EnKF_data$spat_ave_cvfs_EnKF # [1:nx, 1:ntime_filter]
  } # end load Kf, EnKF data
  
  
  # KF or ENKF:
  
  nx_KF_EnKF = dim(spat_ave_cvfs_KF_EnKF)[1]
  if(nx_KF_EnKF != nx){
    message("nx_KF_EnKF=", nx_KF_EnKF, " -- differs from nx")
    stop("Ensure they match")
  }
  
  if(B_source_KF_EnKF_spat_ave){  # take cvfs (space-statio) ( KF or ENKF)
    true_spectra_available = TRUE
    
    # Thin spat_ave_cvfs_KF_EnKF  in time
  
    ntime_spat_ave = dim(spat_ave_cvfs_KF_EnKF)[2]
    time_thin = 10
    ind = seq(from = 1, to = ntime_spat_ave, by = time_thin)
    spat_ave_cvfs_KF_EnKF_thinned = spat_ave_cvfs_KF_EnKF[,ind] # will be used as the input data below
    ntime_B_KF_EnKF = dim(spat_ave_cvfs_KF_EnKF_thinned)[2]
    
  }else{                          # take cvms or EE (space-nstatio)
    if(B_source == "external_KF"){
      if(is.null(B_KF)){
        message("B_KF were not stored in the LSEF run")
        stop("Set  ntime_B_KF_store>0 in config.txt there")
        
      }else{ # B_KF is present
        ntime_B_KF_EnKF = dim(B_KF)[3]
      }
      
    }else if(B_source == "external_EnKF"){
      if(is.null(EE)){
        message("EE were not stored in the LSEF run")
        stop("Set  ntime_EE_store>0 in config.txt there")
        
      }else{ # EE is present
        ntime_B_KF_EnKF = dim(EE)[3]
      }
    }
    
    # Are true spectra available?
    
    if(LEARN){                        # b_LSM will be used as the truth
      true_spectra_available = TRUE
      
    }else{                            # Run & verif anls only:                        
      if(B_source == "external_KF"){  # B_KF is the truth, no local spectra
        true_spectra_available = FALSE
      
      }else if(B_source == "external_EnKF"){
        message("LEARN=F is incompatible with  B_source==external_EnKF")
        stop("Change setup")
      }
    }
  }

  spat_ave_time_ave_cvf_KF_EnKF = apply(spat_ave_cvfs_KF_EnKF, 1, mean)
  b_ave_ave_statio_KF_EnKF =  Re( fft(spat_ave_time_ave_cvf_KF_EnKF, inverse=FALSE) /nx )
  
  # plot(spat_ave_time_ave_cvf_KF_EnKF[1:(nmax/3)], main="spat_ave_time_ave_cvfs_KF")
  # plot(b_shape_KF_EnKF, main="b_shape_KF(circ), \nb_ave_ave_statio_KF (nrmlz)")
  # lines(b_ave_ave_statio_KF_EnKF/b_ave_ave_statio_KF_EnKF[1])
  # 
  # ==> spat_ave_cvfs_KF_EnKF  are consistent with  b_shape_KF_EnKF.
  
  # implied mean fld cvf 
  
  ccvf_med_mean = spat_ave_time_ave_cvf_KF_EnKF
  ccrf_med_mean = ccvf_med_mean / ccvf_med_mean[1]
  
  beyond_L_indices = which(ccrf_med_mean < 0.5, arr.ind = T)
  L_xi_median = dx * beyond_L_indices[1]

  # Use  b_ave_ave_statio_KF_EnKF  to calc "median" analogs of those in PMT
  
  b_median_T = matrix(b_ave_ave_statio_KF_EnKF, nrow = nx, ncol = nx)
  b_median = t(b_median_T)
  Sigma_median = sqrt(b_median)
  WB_median = Sigma2WB(Sigma_median)
  W_median = WB_median$W
  B_median = WB_median$B
  
  # Change  n_repl
  
  if(n_repl > ntime_B_KF_EnKF){
    n_repl = ntime_B_KF_EnKF # adjust  n_repl
  }  
  
  if(LEARN){
    n_repl = ntime_B_KF_EnKF # when Learning, use all available data
    
    LrnSampleThinningStride_prelim = L_xi_median  / dx * 3 # meshes, prelim
    LrnSampleThinningStride = nx / (nx %/% LrnSampleThinningStride_prelim)
    LrnPointsPerRepl = nx  / LrnSampleThinningStride
    if(LrnSampleThinningStride < 2) LrnSampleThinningStride = 2
    if(LrnSampleThinningStride > nmax) LrnSampleThinningStride = nmax
    
    # select n_repl if LEARN=T
    # Ensure that both  k=LrnPointsPerRepl  and   m=minibatch_size  are divisors of  n_train 
    
    n_train = n_repl * LrnPointsPerRepl 
    message("n_train= ", n_train)
  }
  message("n_repl changed: ", n_repl)
}

n_repl10  = ceiling(n_repl/10) ;  n_repl100 = ceiling(n_repl/100)

#--------------------------------------------------------------
#--------------------------------------------------------------
# Create the BANDS

BANDS = CreateExpqBands(nmax, nband, halfwidth_min, nc2, halfwidth_max, 
                        q_tranfu, rectang = FALSE)

tranfu = BANDS$tranfu
band_centers_n  = BANDS$band_centers_n
hhwidth = BANDS$hhwidth
round(band_centers_n,1)
round(hhwidth,1)

tranfu2 = (abs(tranfu))^2 # [i_n, j=1:J]

H_flt = t(tranfu) # NB H_flt is real valued

# "tall" SVD

H_flt_SVD = svd(H_flt)
UH_flt = H_flt_SVD$u
dH_flt = H_flt_SVD$d
VH_flt = H_flt_SVD$v


# "full" SVD

# H_flt_fullSVD = svd(H_flt, nu=J, nv=nx)
# UH_flt_full = H_flt_fullSVD$u
# dH_flt_full = H_flt_fullSVD$d
# VH_flt_full = H_flt_fullSVD$v

#---------------------------------------------
# Omega and its SVD

lplot=F

Omega_SV = Omega_SVD(tranfu2, lplot)

Omega_nmax = Omega_SV$Omega_nmax
Omega_S1   = Omega_SV$Omega_S1
SVD_Omega_nmax = Omega_SV$SVD_Omega_nmax
SVD_Omega_S1   = Omega_SV$SVD_Omega_S1

#--------------------------------------------------------------
#--------------------------------------------------------------
# Preparations for the BIG EXTERNAL (replicates) LOOP

n_repl10  = ceiling(n_repl/10) ;  n_repl100 = ceiling(n_repl/100)

if(CALIBRATE) {
  var_SrMs = 0          # replicate-summed spatially-averaged variance
  crf_SrMs = rep(0, nx) # replicate-summed spatially-averaged crf
  cvf_SrMs = rep(0, nx) # replicate-summed spatially-averaged cvf
  b_SrMs_estm = rep(0, nx) # replicate-summed spatially-averaged estimated SPECTRUM
}

if(LEARN){
  spatInd_NN_learn = seq(from = 1, by = LrnSampleThinningStride, to = nx)
  nx_thinned = length(spatInd_NN_learn)
  if(B_source == "internal_PMT"){
    n_learningSample = nx_thinned * n_repl
  }else{
    n_learningSample = n_repl # if external B_KF cvfs are used, take one cvf per n_repl
  }
  TrueSpectra  = matrix(0, nrow=n_learningSample, ncol=nmaxp1)
  EnsmBandVars = matrix(0, nrow=n_learningSample, ncol=nband)
}

xi_Vt_Ms = c(1:n_repl)
xi_Ve_Ms = c(1:n_repl)
xi_Ve_AEs = c(1:n_repl)
xi_Ve_TAD_Ms = c(1:n_repl)

n_repl_CC = 50
CC     = array(0, dim=c(nx,nx, n_repl_CC))
CC_LSM = array(0, dim=c(nx,nx,     n_repl_CC))
bb_LSM = array(0, dim=c(nx,nmaxp1, n_repl_CC)) # [ix, i_n, i_repl]

# Band space

bband_Ve_MEs    = matrix(0, nrow=n_repl, ncol=nband)
bband_Ve_AEs    = matrix(0, nrow=n_repl, ncol=nband)
bband_Ve_TD_Ms = matrix(0, nrow=n_repl, ncol=nband)  # theor stand dev
bband_Ve_TAD_Ms = matrix(0, nrow=n_repl, ncol=nband) # theor abs dev

bband_Vt_Ms     = matrix(0, nrow=n_repl, ncol=nband)

bband_V_restored_AEs   = matrix(0, nrow=n_repl, ncol=nband)
bband_V_restored_MEs   = matrix(0, nrow=n_repl, ncol=nband)
bband_V_restored_misfit_As   = matrix(0, nrow=n_repl, ncol=nband)
bband_V_restored_misfit_Ms   = matrix(0, nrow=n_repl, ncol=nband)

bband_V_esd_Ms  = matrix(0, nrow=n_repl, ncol=nband)

GGamma_phi__true_Ms  = array(0, dim=c(J,J, n_repl))
ccvm_phi_estm_Ms     = array(0, dim=c(J,J, n_repl))


# Spe space

bb_true_Ms      = matrix(0, nrow=n_repl, ncol=nx) 
b_LSM_MEs       = matrix(0, nrow=n_repl, ncol=nx)
b_LSM_AEs       = matrix(0, nrow=n_repl, ncol=nx) # mean-abs err in spectrum b
b_LSM_AEV_Ms    = c(1:n_repl) ; b_LSM_AEV_Ms[]=0  # AEV deviance "LSM minus TRUTH"

# Phys space: correlations

aaligned_C_Ms        = matrix(0, nrow=n_repl, ncol=nx) # truth
aaligned_C_LSM_MEs   = matrix(0, nrow=n_repl, ncol=nx) # LSM bias
aaligned_CS_lcz_MEs  = matrix(0, nrow=n_repl, ncol=nx) # S_lcz bias
aaligned_C_LSM_AEs   = matrix(0, nrow=n_repl, ncol=nx) # LSM MAE
aaligned_CS_lcz_AEs  = matrix(0, nrow=n_repl, ncol=nx) # S_lcz MAE
nn_nmon = c(1:n_repl)

LLL_u_local = matrix(0, nrow=nx, ncol=n_repl) # loc len scales
ssd_xi_repl = c(1:n_repl) #  SD(xi) for all i_repl

ms_anls_err_Banls_isB_true = c(1:n_repl)
ms_anls_err_Banls_isB_LSM = c(1:n_repl)
ms_anls_err_Banls_isS_lcz = c(1:n_repl)
ms_anls_err_Banls_isB_hybr = c(1:n_repl)
ms_anls_err_Banls_isB_static = c(1:n_repl)

Amx_diag_Banls_isB_true = c(1:n_repl)
Amx_diag_Banls_isB_LSM = c(1:n_repl)
Amx_diag_Banls_isS_lcz = c(1:n_repl)
Amx_diag_Banls_isB_hybr = c(1:n_repl)
Amx_diag_Banls_isB_static = c(1:n_repl)


err_Frob_LSM = c(1:n_repl)
err_Frob_S_lcz = c(1:n_repl)

RelBias_Diag_LSM = c(1:n_repl)
RelBias_Diag_S_lcz = c(1:n_repl)

RelMSE_Diag_LSM = c(1:n_repl)
RelMSE_Diag_S_lcz = c(1:n_repl)

#----------------------------------
# Start of n_repl BIG EXTERNAL LOOP
                                                i_repl=1
                                                for(i_repl in 1:n_repl){
                                                  
                                                if(n_repl100 > 0 & i_repl %% n_repl100 == 1){
                                                  cat("\r",paste0(round(i_repl/n_repl*100,0),'%'))
                                                }
                                                  t0=proc.time()
                                                lplot=FALSE
                                                #if(n_repl == 1) lplot=TRUE

#-----------------------------------------------------------------------
#-----------------------------------------------------------------------
# Specify the true B, W, Sigma, b_true  (and CC) and ENSM
# --- for any of the three sources of true B.                                            
                                                
if(B_source == "internal_PMT"){
  
  # Generate the 3 preTransform flds: chi_S, chi_lambda, chi_gamma
  # (all statio and w the same spectrum,  b_preTransform )                                         
  
  nchi =3 # c(chi_S(x), chi_lambda(x), chi_gamma(x))
  cchi = gen_homProc_fromSpectrum_S1(b_preTransform,   nchi) # lambda, gamma
  cchi = cchi * log(kappa)  # [ix, i_chi]
  
  # chi_S = cchi[,1]
  # plot(chi_S, main="chi_S", type="l")
  # plot(exp(chi_S), main="exp(chi_S)", type="l")
  
  g_cchi = apply(cchi, c(1,2), logistic)
  
  # Generate 3 parameter fields
  
  SDxi_field = SDxi_add   + SDxi_mult   * g_cchi[,1]
  Vxi_field = SDxi_field^2
  lambda = lambda_add + lambda_mult * g_cchi[,2]
  gamma =  gamma_add  + gamma_mult  * g_cchi[,3]
  
  # The local spectra
  #    b(x,n) = c(x)/( 1 + (lambda(x) * (n+n0))^gamma(x) ) 
  # c  is calculated to ensure that 
  #    Var(xi(x)) = \sum{all n on the circle} b[x,n] = S^2(x)
  
  b_true = matrix(0, nrow = nx, ncol = nx) # [ix,i_n]
  
  for (ix in 1:nx){
    b_true[ix, 1:nmaxp1] = 1 /( 1 + (lambda[ix] * nn_half_pn0[])^gamma[ix] )
    b_true[ix, nmaxp2:nx] = rev(b_true[ix, 2:nmax]) # symm
    
    v = sum(b_true[ix,])
    b_true[ix,] = b_true[ix,] / v * Vxi_field[ix]  # nrmlz
  }
  
  # W, B, Sigma (true)
  # Sigma[ix,n+1] = sigma_n(ix) -- the local spectrum
  
  Sigma = sqrt(b_true)
  WB = Sigma2WB(Sigma)
  
  W = WB$W
  B = WB$B
  
  # Calc symm-pos-def sqrt of CVM
  sqB = symm_pd_mx_sqrt(B)$sq
  
  # CREATE the ENSM
  gau_mx_N01=matrix(nrow=nx, ncol=ne, data=rnorm(nx*ne))
  ENSM=sqB %*% gau_mx_N01
}
#-----------------------------------------------------
if(B_source != "internal_PMT"){
  if(B_source_KF_EnKF_spat_ave){  # take spat-statio  cvfs (KF & EnKF treated identically)
    
    b_true_statio =  Re( fft(spat_ave_cvfs_KF_EnKF_thinned[,i_repl], inverse=FALSE) /nx )
    
    b_true = t(matrix(b_true_statio, nrow = nx, ncol = nx))  # b_true[ix,i_n]
    Sigma = sqrt(b_true)
    WB = Sigma2WB(Sigma)
    W = WB$W
    B = WB$B
    
    # Calc symm-pos-def sqrt of CVM
    sqB = symm_pd_mx_sqrt(B)$sq
    
    # CREATE the ENSM
    gau_mx_N01=matrix(nrow=nx, ncol=ne, data=rnorm(nx*ne))
    ENSM=sqB %*% gau_mx_N01
  }
  #-----------------------------------------------------                                               
  if(!B_source_KF_EnKF_spat_ave){    # take  B_KF or EE
    if(LEARN){  # take B_KF or EE_EnKF, fit LSM, & use its output as the truth
      if(B_source == "external_KF"){
        B = B_KF[,,i_repl]
        
        # Calc symm-pos-def sqrt of CVM
        sqB = symm_pd_mx_sqrt(B)$sq
        
        # CREATE the ENSM
        gau_mx_N01=matrix(nrow=nx, ncol=ne, data=rnorm(nx*ne))
        ENSM=sqB %*% gau_mx_N01
        
      }else if(B_source == "external_EnKF"){
        ENSM = EE[,,i_repl]
      }
      
      # Fit LSM t calc b_true and (re)calc B and recalc ENSM (for consistency)
      
      perform_B2S = T
      LSM_KF_EnKF = fit_LSM(ENSM, tranfu, BOOTENS, nB, true_spectra_available=F,  # =F here is OK.
                            perform_B2S, B2S_method, b_shape_KF_EnKF, lplot, 
                            B2S_bbc, niter_bbc, correc_bbc,  # prms for B2S_lines
                            moments, a_max_times, w_a_fg,    # prms for B2S_shape
                            Omega_S1, SVD_Omega_S1, band_centers_n, nSV_discard, # prms for B2S_SVshape
                            NN, TransformSpectrum_type_x, TransformSpectrum_type_y,
                            TransformSpectrum_pow_x, TransformSpectrum_pow_y, Omega_nmax, # prms for B2S_NN
                            a_search_times, na, eps_V_sd, band_Ve_TD, eps_smoo, w_a_rglrz) #prms for B2S_PARAM
      
      b_true = LSM_KF_EnKF$b_LSM
      Sigma = sqrt(b_true)
      WB = Sigma2WB(Sigma)
      W = WB$W
      B = WB$B   # reassign B !!!
      
      # Recalc ENSM
      sqB = symm_pd_mx_sqrt(B)$sq
      gau_mx_N01=matrix(nrow=nx, ncol=ne, data=rnorm(nx*ne))
      ENSM=sqB %*% gau_mx_N01
      
    }else{  # !LEARN: only B_KF can be used here (checked above) 
      B = B_KF[,,i_repl]
      sqB = symm_pd_mx_sqrt(B)$sq
      gau_mx_N01=matrix(nrow=nx, ncol=ne, data=rnorm(nx*ne))
      ENSM=sqB %*% gau_mx_N01
    }
  }    
}
if(i_repl <= n_repl_CC){
  Cv = Cov2VarCor(B)
  C = Cv$C
  CC[,,i_repl] = C
} 
#-----------------------------------------------------                                               
# Save spectra 

# ix=sample(c(1:nx),1)
# dn=nx/2
# mx=max(b_true[ix, 1:dn])
# plot(b_true[ix, 1:dn], main=paste0("b_true at ix=",ix), type="l", ylim=c(0,mx), xlab="n+1")

if(true_spectra_available){
  b_true_Ms = apply(b_true, 2, mean)  # x-mean spectrum
  bb_true_Ms[i_repl,] = b_true_Ms
  
  xi_Vt = apply(b_true, 1, sum) # true variance at all x
  sd_xi = sqrt( mean(xi_Vt) )
  xi_Vt_Ms[i_repl] = mean(xi_Vt)
  
  ssd_xi_repl[i_repl] = sd_xi
}

# Extract spe "shape"  g(n)  so that the real spectrum c/b apxted as  A*g(n/a).
# If the CALIBRATE run has been in effect, then the mean spectrum  b_shape_estm  is used
# Otherwise, the median spectrum is utilized

if(B_source == "internal_PMT"){
  if( exists("b_shape_estm") ){   # Select the spe shape: true or estmtd
    b_shape = b_shape_estm
    
  }else{ 
    b_shape = b_median_1D_nrm[1:nmaxp1]
  }
  
}else{ # external_KF_EnKF
  b_shape = b_shape_KF_EnKF
}

#-----------------------------------------------------------------------
#-----------------------------------------------------------------------
# Fit LSM: 
# 1) Generate the ENSM
# 2) E2B (from ENSM to sample Band variances)
# 3) B2S (Band variances to local Spectra)

perform_B2S = !LEARN # don't perform B2S if LEARN=T

LSM = fit_LSM(ENSM, tranfu, BOOTENS, nB, true_spectra_available,
              perform_B2S, B2S_method, b_shape, lplot, 
              B2S_bbc, niter_bbc, correc_bbc,  # prms for B2S_lines
              moments, a_max_times, w_a_fg,    # prms for B2S_shape
              Omega_S1, SVD_Omega_S1, band_centers_n, nSV_discard, # prms for B2S_SVshape
              NN, TransformSpectrum_type_x, TransformSpectrum_type_y,
              TransformSpectrum_pow_x, TransformSpectrum_pow_y, Omega_nmax, # prms for B2S_NN
              a_search_times, na, eps_V_sd, band_Ve_TD, eps_smoo, w_a_rglrz) #prms for B2S_PARAM

S       = LSM$S
band_Ve = LSM$band_Ve

if(!LEARN) b_LSM           = LSM$b_LSM
if(!LEARN) band_V_restored = LSM$band_V_restored

#-----------------------------------------------------------------------
#-----------------------------------------------------------------------
# Ensm variance. Always subtract ensm mean

xi_Ve = apply(ENSM, 1, var) # ENSM[ix,ie]

xi_Ve_Ms[i_repl]  = mean(xi_Ve)
if(true_spectra_available){
  xi_VeE = xi_Ve - xi_Vt  # error in xi_Ve
  xi_Ve_AEs[i_repl] = ExAbs(xi_VeE)
}

# theoretical estm of SD(S).
# NB: It's SD(S), not Var(S) that is Unbiased. So, we average SD's here.

xi_Ve_TD = xi_Ve * sqrt(2/(ne-1)) # theor SD(xi_Ve)
xi_Ve_TAD = xi_Ve_TD * md2sd_chi2
xi_Ve_TAD_Ms[i_repl] = mean(xi_Ve_TAD)  

if(i_repl == 1 & true_spectra_available){
  xi_Ve_upp = xi_Ve + xi_Ve_TD
  xi_Ve_low = xi_Ve - xi_Ve_TD
  xi_Ve_low[xi_Ve_low<0] = 0
  
  mx=max(max(xi_Ve, xi_Vt, xi_Ve_upp, xi_Ve_low))
  mn=0
  namefile=paste0("./Out/TrueEnsmVars_ne",ne, "ne", ne, "kap", kappa, "NSL", NSL,".png")
  png(namefile, width=7.48, height=5.47, units = "in", res=300)
  par(mgp=c(2.5, 1, 0))
  plot(xi_Vt, type="l", main=paste0("True variance Vt, ensm variance Ve (red), Ve +- SD (grn)"), 
       ylim=c(mn,mx), xlab="Grid point", ylab = "Variance",
       sub=paste0("xi_Vt_Ms=", signif(xi_Vt_Ms[i_repl],4), "   xi_Ve_Ms=", signif(xi_Ve_Ms[i_repl],4)))
  lines(xi_Ve, col="red")
  lines(xi_Ve_low, type="l", col="green", lty=3)
  lines(xi_Ve_upp, type="l", col="green", lty=3)
  abline(h=0, lty=3)
  dev.off()
}

# Localized S

S_lcz = S * C_lcz

# The HYBRID: replace S_lcz

if(B_source == "internal_PMT"){
  if(static_B_mean_median == 1 & exists("B_mean")){
    B_static = B_mean
  }else{
    B_static = B_median
  }
}else{ 
  B_static = B_clim_KF_EnKF
}

B_hybr = w_ensm_hybr*S_lcz + (1-w_ensm_hybr)*B_static

#----------------------------------------------------------------------
#----------------------------------------------------------------------
#                      BAND-SPACE section
#--------------------------------------------------------------
# Calc TRUE band variances from Sigma[ix, i_n], 

if(true_spectra_available){
  band_Vt = t( apply(b_true, 1, function(t) t(tranfu2) %*% t) ) # tranfu2[i_n,j]
  band_Vt_Ms   = apply(band_Vt, 2, mean)   # [band]
  bband_Vt_Ms[i_repl,] = band_Vt_Ms
  
  # Calc band spectra for the Median true spectrum
  
  if(B_source == "internal_PMT"){
    band_VtMed = matrix(0, nrow=nx, ncol=nband)
    for (band in (1:nband)){
      for (ix in 1:nx){
        band_VtMed[ix,band]   = sum( (tranfu2[,band] * Sigma_median[ix,])^2 )
      }
    }
  }
}
#----------------------------------------------------------------------
# Ave S to get the mean crf
# Calibration: estm and accumulate spat-ave crf
# and spat spectrum

if(CALIBRATE){
  tmp = SpatAveCrf_S1(S)
  cvf_Ms = tmp$cvf
  crf_Ms = tmp$crf
  var_Ms = tmp$var_mean
  
  b_SrMs_estm = b_SrMs_estm + b_Ms_estm # from the ENSM
  
  crf_SrMs = crf_SrMs + crf_Ms
  cvf_SrMs = cvf_SrMs + cvf_Ms
  var_SrMs = var_SrMs + var_Ms
  next # cycle the BIG external   i_repl  loop
}

#--------------------------------------------------------------
# Calc bmean -- mean b[n] for all bands, for the true band vars
# and the ensm band vars

if(true_spectra_available){
  BT = band_lbmean(band_Vt, tranfu2, lplot)
  band_bmean_true = BT$band_bmean
  band_lmean = BT$band_lmean
}
band_bmean_ensm = band_lbmean(band_Ve, tranfu2, lplot)$band_bmean

#--------------------------------------------------------------
# Mean & mean-abs & RMS err in band_Ve (spat ave)

if(true_spectra_available)  band_Ve_MEs = apply(band_Ve - band_Vt, 2, mean) 
bband_Ve_MEs[i_repl,]=band_Ve_MEs

if(true_spectra_available)  band_Ve_AEs = apply(band_Ve - band_Vt, 2, ExAbs) 
bband_Ve_AEs[i_repl,]=band_Ve_AEs

# band_V theoretical SD - estm assuming normality of the ensm:  SD(band_Ve)
# NB: It is  SSD(Ve)=sqrt(2/(ne-1))*Ve  (SSD stands for Sample SD) that, 
#     with the unknown true variance Vt, is an unbiased estm of of the true SD(Ve).

band_Ve_TD = sqrt(2/(ne-1)) * band_Ve # "theoretical" SD of sample var
bband_Ve_TD_Ms[i_repl,] = apply(band_Ve_TD, 2, mean)

band_Ve_TAD = band_Ve_TD * md2sd_chi2
bband_Ve_TAD_Ms[i_repl,] = apply(band_Ve_TAD, 2, mean)

#-----------------------------------------------------------------
# Plot band vars fields

if(n_repl == 1 & true_spectra_available){
  j=round(nband)
  mx=max(band_Ve[,1:j], band_Vt[,1:j])
  image2D(x=ii_x, y=c(1:j), z=band_Vt[,1:j], main="band_Vt", zlim=c(0,mx), 
          xlab = "Grid point", ylab = "Band")
  image2D(x=ii_x, y=c(1:j), z=band_Ve[,1:j], main=paste0("band_Ve"), 
          zlim=c(0,mx), xlab = "Grid point", ylab = "Band")
  
  nb=nband
  mx=max(band_Ve_Ms[1:nb], band_Vt_Ms[1:nb])
  plot(band_Vt_Ms[1:nb], main="band_V_Ms: true & ensm (red)\n TMD_Ms (grn)", xlab="band", ylim=c(0,mx))
  lines(band_Ve_Ms[1:nb], col="red")
  lines(bband_Ve_TAD_Ms[i_repl,1:nb], col="green")
}

if(n_repl == 1 & true_spectra_available){
  ix=sample(c(1:nx), 1, replace = FALSE)
  mx=max(band_Ve[ix,], band_Vt[ix,])
  plot(band_Ve[ix,], main=paste0("band_Ve (red), band_Vt (blck)",
                                 "\n TMD (grn).  @ix=",ix), 
       ylim=c(0,mx), type="l", col="red")
  lines(band_Vt[ix,], col="black")
  lines(band_Ve_TAD[ix,], col="green")
  
  ix=sample(c(1:nx), 1, replace = FALSE)
  mx=max(band_bmean_true[ix,], band_bmean_ensm[ix,])
  plot(band_bmean_true[ix,], main=paste0("band_bmean_true (blck) and \n band_bmean_ensm (red)",
                                 "\n  ix=",ix), 
       ylim=c(0,mx), type="l", col="black")
  lines(band_bmean_ensm[ix,], col="red")
}
#--------------------------------------------------------------
# Stats in BAND-SPACE. 

# Plot over x

ixm = nx
if(i_repl == 1 & true_spectra_available){
  for( band in c(1,2,3,seq(from=4, to=nband, by=2)) ){
    if(!BOOTENS){
      band_Ve_upp = band_Ve[1:ixm, band] + band_Ve_TD[,band]
      band_Ve_low = band_Ve[1:ixm, band] - band_Ve_TD[,band]
      band_Ve_low[band_Ve_low<0] = 0
      mx=max(band_Vt[1:ixm, band], band_Ve[1:ixm, band], band_Ve_upp[1:ixm], band_Ve_low[1:ixm])
    }else{
      mx=max(band_Vt[1:ixm, band], band_Ve[1:ixm, band], band_Ve_B[1:ixm,band,])
    }
    namefile=paste0("./Out/band_VeFields_j", round(band_centers_n[band],1), 
                    "hw", round(hhwidth[band],1), 
                    "ne", ne, "kap", kappa, 
                    "NSL", NSL, ".png")
    png(namefile, width=7.48, height=5.47, units = "in", res=300)
    par(mgp=c(2.5, 1, 0))
    plot(band_Vt[1:ixm, band], type="l", xlab="Grid point", ylab="Band variance",
         main=paste0("Band ",band, ":\n V_true (black), V_ensm (red), V_ensm +- SD (grn)"), 
         ylim=c(0,mx))
    lines(band_Ve[1:ixm, band], col="red", lty=1, lwd=2)
    if(!BOOTENS){
      lines(band_Ve_low[1:ixm], col="green", lty=3, lwd=2)
      lines(band_Ve_upp[1:ixm], col="green", lty=3, lwd=2)
    }else{
      for(iB in 1:nB){
        lines(band_Ve_B[1:ixm,band,iB], col=rgb(red=0, green=1, blue=0, alpha=0.5), lwd=0.5, lty=3)
      }
    }
    abline(h=0, lty=3)
    dev.off()
  }
}

# Space averaged stats: plot over bands

j5=min(5,J)

if(n_repl == 1 & true_spectra_available){
  mn=min(0, band_Ve_AEs, band_Ve_MEs, band_Vt_Ms, bband_Ve_TAD_Ms[i_repl,])
  mx=max(band_Ve_AEs, band_Ve_MEs, band_Vt_Ms, bband_Ve_TAD_Ms[i_repl,])
  namefile=paste0("./Out/BandspaceErr_", 
                  "ne", ne, "kap", kappa, 
                  "NSL", NSL, ".png")
  png(namefile, width=7.48, height=5.47, units = "in", res=300)
  par(mgp=c(2.5, 1, 0))
  plot(band_Ve_AEs, lwd=1.5,
       main=paste0("Ensemble band variances: sample & theor errors. Truth",
                   "\n ne=", ne, 
                   " NSL=",NSL, " kappa=", kappa),  
       type="l", xlab="band", ylab="Truth and errors", ylim=c(mn,mx), col="red",
       sub=paste0( "Rel RMS band 1: ",signif(band_Ve_AEs[1]/band_Vt_Ms[1],2),
                   "  mean over bands 1-5: ",signif( mean(band_Ve_AEs[1:j5]/band_Vt_Ms[1:j5]),2 ) ) )
  lines(band_Ve_MEs, col="blue")
  lines(band_Vt_Ms, col="black", lwd=2)
  lines(bband_Ve_TAD_Ms[i_repl,], col="green", lty=3, lwd=2)
  
  leg.txt<-c('MAE', 'Bias', 'Truth', "MD")
  leg.col<-c("red", "blue", "black", "green")
  legend("topright", inset=0, leg.txt, col=leg.col, 
         lwd=c(1.5,2,2), lty=c(1,1,1,3), pch=c(NA,NA,NA,NA),
         pt.lwd=3, cex=1.3, pt.cex=1, bg="white")
  
  abline(h=0, lty=3)
  dev.off()
}

# Band variances plots point by point

if(n_repl == 1 & true_spectra_available){
  ix=sample(c(1:nx),1)
  if(!BOOTENS){
    band_Ve_upp = band_Ve[ix,] + band_Ve_TD[ix,]
    band_Ve_low = band_Ve[ix,] - band_Ve_TD[ix,]
    band_Ve_low[band_Ve_low < 0] = 0
    mx=max(band_Ve_upp, band_Vt[ix,])
  }else{
    mx=max(band_Vt[ix,], band_Ve[ix,], band_Ve_B[ix,,])
  }
  
  plot(band_Ve[ix,], main=paste0("Band variances at ix=", ix), pch=19, 
       col="magenta", ylim=c(0,mx), xlab = "Band", ylab = "V")
  lines(band_Vt[ix,], type = "p", pch=16, lty=3, lwd=3)
  if(!BOOTENS){
    lines(band_Ve_upp, type = "l", lty=3, lwd=2, col="green")
    lines(band_Ve_low, type = "l",  lty=3, lwd=2, col="green")
    leg.txt<-c('Ve', 'Vt', 'Ve +- SD')
  }else{
    for(iB in 1:nB){
      lines(band_Ve_B[ix,,iB], col=rgb(red=0, green=1, blue=0, alpha=0.5), lwd=0.5, lty=3)
    }
    leg.txt<-c('Ve', 'Vt', 'Bootstrap')
  }
  leg.col<-c("magenta", "black", "green")
  legend("topright", inset=0, leg.txt, col=leg.col, 
         lwd=c(NA,NA,2,2), lty=c(NA,NA,3,3), pch=c(19,16,NA,NA),
         pt.lwd=3, cex=1.3, pt.cex=1, bg="white")
}
# End of the BAND-SPACE section.
#----------------------------------------------------------------------
#----------------------------------------------------------------------
# Store the data to train the neural network after the big loop is over

if(LEARN){
  # TrueSpectra  = matrix(0, nrow=n_learningSample, ncol=nmaxp1)
  # EnsmBandVars = matrix(0, nrow=n_learningSample, ncol=nband)
  
  if(B_source == "internal_PMT"){
    TrueSpectra_i_repl  = b_true [spatInd_NN_learn, 1:nmaxp1]
    EnsmBandVars_i_repl = band_Ve[spatInd_NN_learn, 1:nband ]
    
  }else{        # B_source = external_KF or external_EnKF 
    
    if(B_source_KF_EnKF_spat_ave){   # statio cvfs ==> take just one spat point
      TrueSpectra_i_repl  = b_true [1, 1:nmaxp1]
      EnsmBandVars_i_repl = band_Ve[1, 1:nband ]
      
    }else{                           # fitted LSM local spectra
      TrueSpectra_i_repl  = b_true [1, 1:nmaxp1]
      EnsmBandVars_i_repl = band_Ve[1, 1:nband ]
    }
  }
 
  if(i_repl == 1){
    TrueSpectra  = TrueSpectra_i_repl
    EnsmBandVars = EnsmBandVars_i_repl
  }else{
    TrueSpectra  = rbind(TrueSpectra,  TrueSpectra_i_repl)
    EnsmBandVars = rbind(EnsmBandVars, EnsmBandVars_i_repl)
  }
  
  if(i_repl %% 100 == 1){
    plot(b_true [1, 1:nmaxp1], main=paste("Training spectrum \n i_repl=", i_repl))
  }
  
  next # go to the next BIG-loop iteration (skip B2S and anls)
}

#----------------------------------------------------------------------

if(i_repl <= n_repl_CC) bb_LSM[,,i_repl] = b_LSM[,1:nmaxp1]

# Store the spatially-averaged bias & MSE of the spectra

if(true_spectra_available){
  b_LSM_MEs[i_repl,]   = apply(b_LSM   - b_true, 2, mean)
  b_LSM_AEs[i_repl,]   = apply(b_LSM   - b_true, 2, ExAbs)
  
  # Store the spatially-averaged AEV (idealized Anls-Err-Variance based) deviance of
  # the estimated spectra from the true ones
  
  b_LSM_AEV_Ms[i_repl] = AEV_deviance_S1_sample(b_true[,1:nmaxp1], b_LSM[,1:nmaxp1], 
                                                obs_err_variance_supplied=T, obs_err_variance = obs_err_variance)
}

#----------------------------------------------------------------------
#            b_LSM: Restored-BAND-space stats 
# (restored from the estimated local spectra b_LSM)

# Restored-BANDSPACE errors

if(true_spectra_available){
  band_V_restored_err = band_V_restored - band_Vt  # [ix, band], error
  bband_V_restored_AEs[i_repl,] = apply(band_V_restored_err, 2, ExAbs)
  bband_V_restored_MEs[i_repl,] = apply(band_V_restored_err, 2, mean)
  
  band_V_restored_misfit = band_V_restored - band_Ve # misfit wrt original Ve
  bband_V_restored_misfit_As[i_repl,] = apply(band_V_restored_misfit, 2, ExAbs)
  bband_V_restored_misfit_Ms[i_repl,] = apply(band_V_restored_misfit, 2, mean)
}

#----------------------------------------------------------------------
#----------------------------------------------------------------------
# LSM Deliverables: Sigma, W_LSM, B_LSM

Sigma_LSM = sqrt(b_LSM)

WB = Sigma2WB(Sigma_LSM)
B_LSM = WB$B
W_LSM = WB$W

#------------------------------------
# Thresholding W_LSM

# sparsity of W_LSM

sparsity_W_orig = sum(W_LSM == 0) / (nx^2)
sparsity_W_orig

if(glob_loc_thresholding == 1){
  W_max = max(W_LSM)
  thres = rel_W_threshold * W_max
  W_LSM[W_LSM < thres] =0
  
}else if(glob_loc_thresholding == 2){ # threshold along rows
  wW_max = apply(W_LSM, 1, max)
  tthres = rel_W_threshold * wW_max
  for (ix in 1:nx){
    vanish = which(W_LSM[ix,] < tthres, arr.ind = T)
    W_LSM[ix, vanish] = 0
  }
}

# ==> Little difference betw glob_loc_thresholding=1 and =2:
#     both in sparsity and the anls RMSE.

sparsity_W_thresholded = sum(W_LSM == 0) / (nx^2)
# message("sparsity_W_thresholded=", signif(sparsity_W_thresholded,2))

# Recompute  B_LSM  from the thresholded W_LSM

if(rel_W_threshold > 1e-5){
  B_LSM = W_LSM %*% t(W_LSM)
}

#----------------------------------------------------------------------
#----------------------------------------------------------------------
#                       STATS of spe & covs

# B_LSM, S_lcz, & B cvf-plots

# zmin = min(B, B_LSM, S_lcz)
# zmax = max(B, B_LSM, S_lcz)
# image2D(B_LSM, main="B_LSM", zlim=c(zmin, zmax))
# image2D(B, main="B",         zlim=c(zmin, zmax))
# image2D(S_lcz, main="S_lcz", zlim=c(zmin, zmax))

# which(B_LSM == max(B_LSM), arr.ind = TRUE)

# mx=max(b_LSM, b_true)
# image2D(b_true, main="b_true", zlim=c(0,mx))
# image2D(b_LSM, main="b_LSM", zlim=c(0,mx))

# B_LSM: PHYS-space stats

if(0==1){
  ix=sample(c(1:nx), 1)
  
  # artificial spe window just to look of its effect on the kernel
  
  b_LSM_loc = b_LSM[ix,]
  
  SPE_WINDOW = F
  if(SPE_WINDOW){
    spe_window = c(1:nx)
    spe_window[] = 0
    ncut=nmax/8
    spe_window[1:(ncut+1)] = 1 - (c(0:ncut) / ncut)^2
    spe_window[nmaxp2:nx] = spe_window[rev(2:nmax)]
    plot(spe_window)
    
    b_LSM_loc = b_LSM[ix,] * spe_window
  }
  plot(b_LSM_loc[1:nmaxp1])

  B_LSM_loc = Re( fft(b_LSM_loc, inverse=TRUE) )
  
  mn=min(B[ix,], B_LSM[ix,], S_lcz[ix,], B_LSM_loc)
  mx=max(B[ix,], B_LSM[ix,], S_lcz[ix,], B_LSM_loc)
  plot(B[ix,], main=paste0("B_tru, B_LSM (red), S_lcz (blu)\nB_LSM_loc (grn) at ix=",ix), 
       ylim=c(mn,mx), type="l", lwd=2)
  lines(B_LSM[ix,], col="red", lwd=2)
  lines(S_lcz[ix,], col="blue", lwd=1.5)
  lines(B_LSM_loc, col="green", lwd=2, lty=2)
  
}
if(n_repl == 1){
  
  # Evaluate the macro-scale of u(rho)
  # R_u^2 = sum (\sigma[l])^2 / (sum \sigma[l])^2
  
  Rscale =  sqrt( apply( Sigma_LSM, 1, function(t) sqrt( sum(t^2)/( sum(t) )^2 ) )  )
  ixmin = which(Rscale==min(Rscale), arr.ind = T)
  ixmax = which(Rscale==max(Rscale), arr.ind = T)
  plot(Rscale)
}

# b_LSM: SPE-space stats

if(n_repl == 1 & true_spectra_available){
  ix=sample(c(1:nx), 1, replace = FALSE)
  nm=nmax/2
  plot(b_true[ix,1:nm]/b_true[ix,1], type="l", ylim=c(0,1), lwd=2, 
       main=paste0("b_n at ix=", ix, 
                   ":\n true (black, thick), LSM (red)"), xlab="n+1")
  lines(b_LSM[ix,1:nm]/b_LSM[ix,1], col="red")
  abline(h=0)
}

if(n_repl == 1){
  d=nx/8
  ix=sample(c((d+1):(nx-d)),1)
  # ix=(ix+2) %% nx
  mx=max( max(B[ix, (ix-d):(ix + d)]), max((S_lcz[ix, (ix-d):(ix + d)])), max((B_LSM[ix, (ix-d):(ix + d)])) )
  mn=min( min(B[ix, (ix-d):(ix + d)]), min((S_lcz[ix, (ix-d):(ix + d)])), min((B_LSM[ix, (ix-d):(ix + d)])) )
  if(mn > 0) mn=0
  plot(B[ix, (ix-d):(ix + d)], type="l", lwd=2, main="Row: B, B_LSM(red), S_lcz(blu)", 
       sub=paste0("i_repl=", i_repl, "  ix=",ix), xlab="Distance, meshes", ylim=c(mn,mx))
  lines(B_LSM[ix, (ix-d):(ix + d)], col="red")
  lines(S_lcz[ix, (ix-d):(ix + d)], col="blue")
  
}

if(1==2){
  d=nx/8
  ix=sample(c((d+1):(nx-d)),1)
  # ix=(ix+2) %% nx
  mx=max( max(B[ix, (ix-d):(ix + d)]) )
  mn=min( min(B[ix, (ix-d):(ix + d)]) )
  if(mn > 0) mn=0
  plot(B[ix, (ix-d):(ix + d)], type="l", lwd=1.5, main="Row: B_true", 
       sub=paste0("i_repl=", i_repl, "  ix=",ix), xlab="Distance, meshes", ylim=c(mn,mx))
  
}

norm(B_LSM-B, type = "2") / norm(B, type = "2") 
norm(S_lcz-B, type = "2") / norm(B, type = "2") 

#-----------------------
# Plot kernels (rows of W_...) 

if(i_repl %% 10 == 1){
  d=nmax/8
  iy1=nmax - d
  iy2=nmax + d
  
  ix=sample(c(1:nx), 1, replace = FALSE)
  alignedRow_W     = symm_cvm_row(W[ix,], nx, ix)
  alignedRow_W_med = symm_cvm_row(W_median[ix,], nx, ix)
  alignedRow_W_LSM = symm_cvm_row(W_LSM[ix,], nx, ix)
  
  mn = min(alignedRow_W, alignedRow_W_med, alignedRow_W_LSM)
  mx = max(alignedRow_W, alignedRow_W_med, alignedRow_W_LSM)
  
  plot(alignedRow_W[iy1:iy2], main=paste0("kernel: true, med (blu), LSM (red) \n at ix=", ix), 
       type="l", xlab="rho, mesh sizes", ylab="u", ylim=c(mn,mx), col="black")
  lines(alignedRow_W_med[iy1:iy2], col="blue")
  lines(alignedRow_W_LSM[iy1:iy2], col="red")  
}

#------------------------------
# Biases & MAEs in the CRMs/CVMs

C_LSM  = Cov2VarCor(B_LSM)$C

if(i_repl <= n_repl_CC) CC_LSM[,,i_repl] = C_LSM

CS_lcz = Cov2VarCor(S_lcz)$C

# Align C, CS_lcz, C_LSM  so that the main diagonal 
# becomes vertical and stands in the middle on the plot (at ix=nmax=nx/2)

aligned_C = C  # init
aligned_C_LSM = C_LSM  # init
aligned_CS_lcz = S_lcz  # init

# Length scales: L0, L1, L2

dd = abs(xx_km - xx_km[nmax])
LL0_t = c(1:nx) ; LL0_s = LL0_t ; LL0_l = LL0_t
                                                
for (ix in 1:nx){
  row     = C[ix,]
  row_cov = B[ix,]
  
  if(l_CRL_COV_plots == 1){
    row4plot = row
  }else if(l_CRL_COV_plots == 2){
    row4plot = row_cov
  }
  alignedRow = symm_cvm_row(row4plot, nx, ix) # for plotting
  aligned_C[ix,] = alignedRow
  
  alignedRow = symm_cvm_row(row, nx, ix)      # for len scales evaluation
  
  LL0_t[ix] = sum( abs(alignedRow)*dx_km ) /2                # macro scale
  
  
  row     = CS_lcz[ix,]
  row_cov = S_lcz[ix,]
  
  if(l_CRL_COV_plots == 1){
    row4plot = row
  }else if(l_CRL_COV_plots == 2){
    row4plot = row_cov
  }
  alignedRow = symm_cvm_row(row4plot, nx, ix)
  
  aligned_CS_lcz[ix,] = alignedRow
  
  alignedRow = symm_cvm_row(row, nx, ix)
  
  LL0_s[ix] = sum( abs(alignedRow)*dx_km ) /2                # macro scale
  
  
  row     = C_LSM[ix,]
  row_cov = B_LSM[ix,]
  
  if(l_CRL_COV_plots == 1){
    row4plot = row
  }else if(l_CRL_COV_plots == 2){
    row4plot = row_cov
  }
  alignedRow = symm_cvm_row(row4plot, nx, ix)
  aligned_C_LSM[ix,] = alignedRow
  
  alignedRow = symm_cvm_row(row, nx, ix)
  
  LL0_l[ix] = sum( abs(alignedRow)*dx_km ) /2                # macro scale
}
  # Plot len scales

if(i_repl == n_repl){
  mx=max(LL0_t, LL0_s, LL0_l)
  plot(LL0_t, ylim=c(0,mx), main = "Macro scale: true (black), \n S_lcz (blue), LSM (red)", type="l")
  lines(LL0_s, col="blue")
  lines(LL0_l, col="red")
}

aaligned_C_Ms[i_repl,]       = apply(aligned_C,      2, mean) # truth

aaligned_C_LSM_MEs[i_repl,]  = apply(aligned_C_LSM - aligned_C,  2, mean)
aaligned_C_LSM_AEs[i_repl,]  = apply(aligned_C_LSM - aligned_C,  2, ExAbs)

aaligned_CS_lcz_MEs[i_repl,] = apply(aligned_CS_lcz - aligned_C, 2, mean)
aaligned_CS_lcz_AEs[i_repl,] = apply(aligned_CS_lcz - aligned_C, 2, ExAbs)

#-------------------------
# Monotonicity of crl C_LSM

ix_c = nmax
eps=3e-2
n_nmon = c(1:nx)

for (ix in 1:nx){
  row = C_LSM[ix,]
  alignedRow = symm_cvm_row(row, nx, ix)
  
  # left half
  ind = 2:ix_c
  growth = alignedRow[ind] > alignedRow[ind-1] - eps
  
  # right half
  ind = ix_c:(nx-1)
  decay = alignedRow[ind] > alignedRow[ind+1] - eps
  
  n_nmon[ix] = sum(!growth) + sum(!decay)
}
nn_nmon[i_repl] = sum(n_nmon)

#---------------------
# Matrix err norms

err_Frob_LSM[i_repl]   = norm(B_LSM-B, type = "F") / norm(B, type = "F") 
err_Frob_S_lcz[i_repl] = norm(S_lcz-B, type = "F") / norm(B, type = "F") 

RelBias_Diag_LSM[i_repl]   = mean(diag(B_LSM-B)) / mean(diag(B))
RelBias_Diag_S_lcz[i_repl] = mean(diag(S_lcz-B)) / mean(diag(B))

RelMSE_Diag_LSM[i_repl]   = mean(diag( (B_LSM-B)^2 )) / mean(diag(B^2))
RelMSE_Diag_S_lcz[i_repl] = mean(diag( (S_lcz-B)^2 )) / mean(diag(B^2))

#------------------------------------------------------------------
#------------------------------------------------------------------
# ANLS
# Perform the secondary KF's anls with:
# 
# B_specified = B_true
# B_specified = S_lcz
# B_specified = B_LSM
# 
# And compute the 3 respective anls-err cvms A
# A = (I-KH) B_true (I-KH)^T + K R K^T
# (B_true is B in this program)

#----------------------------------
# Preparations to the ANLS

# FG=0

x_f = c(1:nx) ;  x_f[] =0

# Generate truth using the true fcst-err mdl: xi=W*N(0,I):
# x_true = x_f - e_f = -xi (minus the FG error)
# Since the CVM of xi is B=W*W^T, we simulate xi as 
# xi=W*gau_N01, whr gau_N01 is the N(0,I) noise

gau_N01 = rnorm(nx, mean=0, sd=1) 
xi = W %*% gau_N01
x_true = -xi

# Specify obs-err SD

var_FG_err = median(diag(B))
sd_obs = sd_obs_rel_FG * sqrt(var_FG_err)

#--------------
# Generate OBS: x_obs, H, R

OBS = gen_obs(x_true, n_obs, sd_obs, repeated_obs_location, Uniform = uniform_obs_cover)

H = OBS$H
R = OBS$R
x_obs = OBS$x_obs
 
#----------------------------------
# ANLS

ANLS_opt = lin_determ_anls(as.matrix(x_f), as.matrix(x_obs), H, B, R, B)
ANLS_LSM = lin_determ_anls(as.matrix(x_f), as.matrix(x_obs), H, B_LSM, R, B)
ANLS_S   = lin_determ_anls(as.matrix(x_f), as.matrix(x_obs), H, S, R, B)
ANLS_lcz = lin_determ_anls(as.matrix(x_f), as.matrix(x_obs), H, S_lcz, R, B)
ANLS_B_hybr = lin_determ_anls(as.matrix(x_f), as.matrix(x_obs), H, B_hybr, R, B)
ANLS_static = lin_determ_anls(as.matrix(x_f), as.matrix(x_obs), H, B_static, R, B)

# plot(diag(ANLS_opt$A), type="l")
# lines(diag(ANLS_LSM$A), col="red")
# lines(diag(ANLS_lcz$A), col="blue")
# lines(diag(ANLS_S$A), col="green")
# 
# plot((ANLS_opt$X_a), type="l")
# lines(x_true, lty=2, col="gold")
# lines((ANLS_LSM$X_a), col="red")
# lines((ANLS_lcz$X_a), col="blue")
# lines((ANLS_S$X_a), col="green")

#----------------------------------
# store anls-err stats

ms_anls_err_Banls_isB_true[i_repl] = Ex2(ANLS_opt$X_a - x_true)
ms_anls_err_Banls_isB_LSM [i_repl] = Ex2(ANLS_LSM$X_a - x_true)
ms_anls_err_Banls_isS_lcz [i_repl] = Ex2(ANLS_lcz$X_a - x_true)
ms_anls_err_Banls_isB_hybr[i_repl] = Ex2(ANLS_B_hybr$X_a - x_true)
ms_anls_err_Banls_isB_static [i_repl] = Ex2(ANLS_static$X_a - x_true)

Amx_diag_Banls_isB_true[i_repl] = mean(diag(ANLS_opt$A))
Amx_diag_Banls_isB_LSM [i_repl] = mean(diag(ANLS_LSM$A))
Amx_diag_Banls_isS_lcz [i_repl] = mean(diag(ANLS_lcz$A))
Amx_diag_Banls_isB_hybr[i_repl] = mean(diag(ANLS_B_hybr$A))
Amx_diag_Banls_isB_static [i_repl] = mean(diag(ANLS_static$A))

# plot(x_true)
# lines(ANLS_opt$X_a)
# lines(ANLS_LSM$X_a, col="red")
# lines(ANLS_lcz$X_a, col="blue")
# 
# plot(ANLS_lcz$X_a - x_true, col="blue", type="l")
# lines(ANLS_LSM$X_a - x_true, col="red")
# #lines(ANLS_opt$X_a - x_true)
# 
# plot(abs(ANLS_lcz$X_a - x_true) - abs(ANLS_LSM$X_a - x_true), col="blue", type="l")
# abline(h=0)
# mean(abs(ANLS_lcz$X_a - x_true) - abs(ANLS_LSM$X_a - x_true), col="blue", type="l") / mean(abs(ANLS_lcz$X_a - x_true))

#------------------------------------------------------------------
                                       } # end of n_repl BIG external LOOP
#---------------------------------------------------------
#---------------------------------------------------------
# Calibration: the averaged spat-ave crf & spectrum

if(CALIBRATE){
  
  #----------------------
  # mean var, crf
  
  var_MrMs = var_SrMs / n_repl
  
  var_med
  var_MrMs
  
  cvf_Msr = cvf_SrMs / n_repl
  crf_Msr = crf_SrMs / n_repl
  b_Msr_estm = b_SrMs_estm / n_repl
  
  cvf_from_meanSpectrum = Re( fft(b_Msr_estm, inverse = T) )
  cvf_from_meanSpectrum[1]
  
  nm=nmax/2
  mx=max(crf_Msr[1:nm], ccrf_med_mean[1:nm])  
  mn=min(crf_Msr[1:nm], ccrf_med_mean[1:nm])
  plot(x=xx_km[1:nm], y=crf_Msr[1:nm], main="CRF: mean (points), median (line)", 
       ylim=c(mn,mx), xlab = "Distance, km", ylab="CRF")
  lines(x=xx_km[1:nm], y=ccrf_med_mean[1:nm])
  abline(h=0)
  
  # nm=nmax/2
  # mx=max(cvf_Msr[1:nm]/cvf_Msr[1], ccrf_med_mean[1:nm])  
  # mn=min(cvf_Msr[1:nm]/cvf_Msr[1], ccrf_med_mean[1:nm])
  # plot(cvf_Msr[1:nm]/cvf_Msr[1], main="cvf_Msr/cvf_Msr[1] (points), crf_median (line) \n from spec (red)", 
  #      ylim=c(mn,mx))
  # lines(ccrf_med_mean[1:nm])
  # lines(cvf_from_meanSpectrum[1:nm]/cvf_from_meanSpectrum[1], col="red")
  # 
  # nm=nmax/2
  # mx=max(cvf_Msr[1:nm]/cvf_Msr[1], ccrf_med_mean[1:nm])  
  # mn=min(cvf_Msr[1:nm]/cvf_Msr[1], ccrf_med_mean[1:nm])
  # plot(cvf_Msr[1:nm]/cvf_Msr[1], main="cvf_Msr/cvf_Msr[1] (points), crf_median (line)", ylim=c(mn,mx))
  # lines(ccrf_med_mean[1:nm])
  # 
  #==> replicate-averaging crf or cvf? -- gives little difference in the resulting crf.
  
  #----------------------
  # mean spectrum
 
  b_from_crf_Msr = fft(crf_Msr, inverse = FALSE) / nx
  
  max(abs(Im(b_from_crf_Msr)))
  b_from_crf_Msr = Re(b_from_crf_Msr)
  
  # b_from_crf_Msr_nrm = b_from_crf_Msr / b_from_crf_Msr[1]
  
  plot(b_from_crf_Msr, main="b_from_crf_Msr")
  lines(b_median_1D_nrm, main="b_median_1D_nrm") 
  
  nm=nmax/2
  plot(b_from_crf_Msr[1:nm], main="Spectrum: mean (points), median (line)",
       xlab = "wvn", ylab="Spectra")
  lines(b_median_1D_nrm[1:nm], main="b_median_1D_nrm")
  
  b_from_crf_Msr_half = b_from_crf_Msr[1:nmaxp1]
  
  # Smoo the space-and-"time" mean spectrum, additionally, over n
  
  nsweep=0
  b_shape_estm = ThreePointSmoo_segment(b_from_crf_Msr_half, nsweep, maintainMx = FALSE)
  b_shape_estm = ThreePointSmoo_segment(b_Msr_estm[1:nmaxp1], nsweep, maintainMx = FALSE)
  
  inm=nmax/3
  mx=max(b_shape_estm[1:inm], b_Msr_estm[1:inm], b_median_1D_nrm[1:inm])
  plot(b_shape_estm[1:inm], ylim=c(0, mx),
       main="b_shape_estm from crf (circ) \ndirectly (red), median(grn)")
  lines(b_Msr_estm[1:inm], col="red")
  lines(b_median_1D_nrm[1:inm], col="green")
  
  #---------------------
  # Find min/max variances in TrueSpectra
  
  TrueSpectra = unname(TrueSpectra)
  vars_true = apply(TrueSpectra, 1, function(t) t[1] + t[nmaxp1] + 2*sum(t[2:nmax]))
  message("min(sd_true) = ", signif(sqrt(min(vars_true)),3))
  message("max(sd_true) = ", signif(sqrt(max(vars_true)),3))
  
  #---------------------
  # Mean CVM
  
  sigma_Msr_estm = sqrt(b_Msr_estm)
  Sigma_Msr_estm = t( matrix(sigma_Msr_estm, nrow = nx, ncol = nx) )  # [ix, i_n]
  tmp = Sigma2WB(Sigma_Msr_estm)
  B_mean = tmp$B
  
  image2D(B_mean, main="B_mean")
  image2D(B_median, main="B_median")
  
  stop("Calibration run OK")
}

#---------------------------------------------------------
# Training the NN.
# x_train = TrueSpectra  = matrix(0, nrow=n_learningSample, ncol=nmaxp1)
# y_train = EnsmBandVars = matrix(0, nrow=n_learningSample, ncol=nband)

if(LEARN){
  message("Start NN training")

  x_train = EnsmBandVars
  y_train = TrueSpectra
  
  # it = sample(1:dim(TrueSpectra)[1], 1)
  # plot(TrueSpectra[it,], type="l")
  
  x_train_transf = TransformSpectrum(x_train, type=TransformSpectrum_type_x, pow=TransformSpectrum_pow_x)
  y_train_transf = TransformSpectrum(y_train, type=TransformSpectrum_type_y, pow=TransformSpectrum_pow_y)
  n_sample = n_learningSample
  n_train = n_sample
  
  in_dim  = dim(x_train_transf)[2]
  out_dim = dim(y_train_transf)[2]

  # Convert to torch tensors
  
  x_train_torch = torch_tensor(x_train_transf, dtype = torch_float())
  y_train_torch = torch_tensor(y_train_transf, dtype = torch_float())
  
  #----------------------
  # define the net
  
  mult = 20 # 20 with 2 hidden layers
  n_hidden_layers = 2  # 1,2,3 (2 nrm)
  units_hidden_layers = c(1:n_hidden_layers) # init
  units_hidden_layers[] = in_dim * mult
  
  NN <- nn_sequential(
    nn_linear(in_dim, units_hidden_layers[1]),                 # h1_in =x %*% W_1 + b_1
    nn_relu(),                                                 # h1_out = RelU(h1_in)
    nn_linear(units_hidden_layers[1], units_hidden_layers[2]), # h2_in = h1_out %*% W_1 + b_1
    nn_relu(),                                                 # h2_out = RelU(h2_in)
    # nn_linear(units_hidden_layers[2], units_hidden_layers[3]), # h3_in = h2_out %*% W_2 + b_2
    # nn_relu(),                                                 # h3_out = RelU(h3_in)
    nn_linear(units_hidden_layers[n_hidden_layers], out_dim)#,    # y = h3_out %*% W_3 + b_3
    # nn_relu()
  )
  
  #----------------------
  # Define cost (loss) and optimizer
  
  L2LossFunction = nn_mse_loss()  
  optimizer = optim_adam(NN$parameters, lr = 3e-3)  # 0.003 for mbs2500
  
  #----------------------
  # Minibatches
  
  if(n_train < minibatch_size) minibatch_size = n_train
  if(n_train %% minibatch_size != 0){
    stop("Change minibatch_size (should divide n_train)")
  }
  minibathes_per_epoch = n_train / minibatch_size
  
  loss_history = matrix(0, nrow = minibathes_per_epoch, ncol = epochs) # init
  ind_regular = c(1:n_train)
  
  #----------------------
  # Train the net
  
  count=0
  count_max = epochs * minibathes_per_epoch
  r = obs_err_variance / nx*10  # obs-err variance per wvn
  
  for(epoch in 1:epochs){
    ind_shuffled = sample(ind_regular) # shuffle the training sample each epoch
    
    for(minibatch in 1:minibathes_per_epoch){
      count = count +1
      # generate minibatch's indices
      i1 = (minibatch -1) * minibatch_size +1
      i2 = i1 + minibatch_size -1
      ind = ind_shuffled[i1:i2]
      
      optimizer$zero_grad()
      
      ff = y_train_torch[ind,]      # f = truth
      gg = NN(x_train_torch[ind,])  # g = y_train_pred_torch
      
      if(loss_type == "L2"){
        loss = L2LossFunction(ff, gg)   
        
      }else if(loss_type == "AEV"){
        loss = AEV_loss(ff, gg, r)
      }
      
      # Check Training
      if(count %% 10 == 1){
        message(paste0(" Epoch:", epoch, "  total count of minibatches=", 
            signif(count / count_max *100,2),"%   Loss: ", 
            signif(loss$item(),2)))
        
        i=sample(1:minibatch_size, 1)
        # i=1
        y_true = as.array(ff[i,])
        y_pred = as.array(gg[i,], drop=T)
        mx=max(y_true, y_pred)
        mn=min(y_true, y_pred)
        plot(y_true, type = "l",
             main=paste0("y, pred(red), loss=", signif(as.numeric(loss),3)), ylim=c(mn,mx))
        lines(y_pred, col="red")
        abline(h=0)
      }
      
      loss$backward()
      optimizer$step()
      
      loss_history[minibatch, epoch] = as.numeric(loss)
      
    } # end minibatch loop
  }  # end epoch loop

  plot(log(as.vector(loss_history)))
  # plot(as.vector(loss_history))
  
  # The resulting NN predictions for the whole training dataset
  y_pred_transf_full = as.array( NN(x_train_torch[,]) )
  
  # Back transform the NN predictions 
  y_pred_full = TransformSpectrum(y_pred_transf_full, TransformSpectrum_type_y, 
                                   TransformSpectrum_pow_y, inverse = T)
  # min(y_train_pred)
  
  i=sample(1:n_sample, 1)
  # i=1
  mn = min(y_train[i,], y_pred_full[i,])
  mx = max(y_train[i,], y_pred_full[i,])
  plot(y_train[i,], ylim=c(mn,mx))
  lines(y_pred_full[i,], col="red")

  #----------------------
  # diagnostics
  
  # detect small-scale jiggling
  
  # d2_true = apply(y_train, 1, D2norm)
  # sum(d2_true)
  # d2_pred = apply(y_train_pred, 1, D2norm)
  # sum(d2_pred)
  
  # d4_true = apply(y_train, 1, D4norm)
  # sum(d4_true)
  # d4_pred = apply(y_train_pred, 1, D4norm)
  # sum(d4_pred)
  
  # Anls-err variance loss

  loss_aev_mean = AEV_deviance_S1_sample(y_train, y_pred_full, 
                   obs_err_variance_supplied=T, obs_err_variance = obs_err_variance)
  message("loss_aev_mean=", signif(loss_aev_mean,3))
  
  # badly non-monotone spectra
  z = apply(y_pred_full, 1, NmonotSpec)
  message("Monotone spectra fraction = ", signif(mean(z),3))
  
  rrmse = sqrt( sum( (y_pred_full - y_train)^2 ) / sum( (y_train)^2 ) )
  message("rel rmse self predict = ", signif(rrmse,3))
  
  # i = sample(1:nn_sample, 1)
  # i_sample = ii_sample[i]
  # mx=max(y_train[i_sample,], y_train_pred[i_sample,])
  # plot (y_train[i_sample,], main=paste0("loss_aev=", signif(lloss_aev[i],2)), ylim=c(0,mx))
  # lines(y_train_pred[i_sample,], col="red")
  # 
  # g_circ = c( y_train[i_sample,] , rev( y_train[i_sample,2:nmax] ) )
  # u_true = Re(fft(g_circ, inverse = T))
  # 
  # g_circ = c( y_train_pred[i_sample,] , rev( y_train_pred[i_sample,2:nmax] ) )
  # u_NN = Re(fft(g_circ, inverse = T))
  # 
  # mn= min(u_true, u_NN)
  # mx= max(u_true, u_NN)
  # plot(u_true, main=paste0("true kernel, NN kernel (red) \nloss_aev=", 
  #                                signif(lloss_aev[i],2)), ylim=c(mn,mx))
  # lines(u_NN, col="red")
  # abline(h=0)
  # 
  #------------------------------------------
  # Finally save the NN model
  
  torch_save(NN, "NN.pt")
  
  stop("\r Finish after NN training \r")
}


#---------------------------------------------------------
# OVERALL STATS

# Mean field variances: tue & ensm

xi_Vt_Msr = mean(xi_Vt_Ms)
xi_Ve_Msr = mean(xi_Ve_Ms)

xi_Ve_AEsr   = mean(xi_Ve_AEs) 
xi_Ve_TAD_Msr = mean(xi_Ve_TAD_Ms) 

i_repl=sample(1:n_repl_CC,1)
ix=sample(1:nx,1)
plot(bb_LSM[ix,,i_repl]/bb_LSM[ix,1,i_repl], main="b_LSM nrmlzd (red), b_shape, b_mean_KF(grn)", 
     sub=paste0("i_repl=", i_repl, "  ix=",ix), xlab="Wavenumber+1", col="red", ylim=c(0,1), type="l") 
lines(b_shape/b_shape[1])
abline(h=0)

b_LSM_mean = apply(bb_LSM, 2, mean)

inm=nmax/3
plot(b_LSM_mean[1:inm]/b_LSM_mean[1], main="b_LSM_mean nrmlzd (red) \nb_shape, b_mean_KF(grn)", 
     sub=paste0("i_repl=", i_repl, "  ix=",ix), xlab="Wavenumber+1", col="red", ylim=c(0,1), type="l") 
lines(b_shape[1:inm]/b_shape[1])
if(exists("b_shape_KF_EnKF")) lines(b_shape_KF_EnKF[1:inm], col="green")
abline(h=0)


#=======================================
# ANLS stats

# (1) A-mx (anls-err CVM) based stats

tt=Amx_diag_Banls_isB_true
ll=Amx_diag_Banls_isB_LSM
ss=Amx_diag_Banls_isS_lcz
mm=Amx_diag_Banls_isB_static # mean-B
hh=Amx_diag_Banls_isB_hybr

if(n_repl > 1){
  mx=max(max(hh-ll),0)
  mn=min(min(hh-ll),0)
  plot(hh-ll, ylim=c(mn,mx), type="l", col="red",
       xlab="Replicate number", ylab="S_lcz anls-err std   MINUS   LSM anls-err std",
       main="anls_DE(S_lcz) - anls_DE(B_LSM) \n(Difference of anls-err std for the 2 anls)")
  abline(h=0)
}

t=sqrt(mean(tt))
l=sqrt(mean(ll))
s=sqrt(mean(ss))
m=sqrt(mean(mm))
h=sqrt(mean(hh))

anls_RMSE_B_true = t
anls_RMSE_B_LSEF = l
anls_RMSE_B_EnKF = s
anls_RMSE_B_hybr = h
anls_RMSE_B_mean = m

REE_S_lcz =(l-t)/(s-t)
REE_B_hybr =(l-t)/(h-t)
REE_B_static =(l-t)/(m-t)

# sampling error std: bootstrap

n_boo = 1000
rs_boo = c(1:n_boo) # init
rh_boo = c(1:n_boo) # init
rv_boo = c(1:n_boo) # init
for (i in 1:n_boo){
  ii_boo = sample(c(1:n_repl), n_repl, replace = TRUE)
  t=sqrt(mean(tt[ii_boo]))
  l=sqrt(mean(ll[ii_boo]))
  s=sqrt(mean(ss[ii_boo]))
  h=sqrt(mean(hh[ii_boo]))
  m=sqrt(mean(mm[ii_boo]))
  rs_boo[i] = (l-t)/(s-t)
  rh_boo[i] = (l-t)/(h-t)
  rv_boo[i] = (l-t)/(m-t)
}

REE_S_lcz_samplNoise = sd(rs_boo) 
REE_B_hybr_samplNoise = sd(rh_boo) 
REE_B_static_samplNoise = sd(rv_boo) 

#-----------------------
# (2) Sample based stats

tt = ms_anls_err_Banls_isB_true
ll = ms_anls_err_Banls_isB_LSM
ss = ms_anls_err_Banls_isS_lcz
hh = ms_anls_err_Banls_isB_hybr
mm = ms_anls_err_Banls_isB_static

t=sqrt(mean(tt))
l=sqrt(mean(ll))
s=sqrt(mean(ss))
h=sqrt(mean(hh))
m=sqrt(mean(mm))

REE_S_lcz_MCarlo =(l-t)/(s-t)
REE_B_hybr_MCarlo =(l-t)/(h-t)
REE_B_static_MCarlo =(l-t)/(m-t)

for (i in 1:n_boo){
  ii_boo = sample(c(1:n_repl), n_repl, replace = TRUE)
  t=sqrt(mean(tt[ii_boo]))
  l=sqrt(mean(ll[ii_boo]))
  s=sqrt(mean(ss[ii_boo]))
  rs_boo[i] = (l-t)/(s-t)
  rh_boo[i] = (l-t)/(h-t)
  rv_boo[i] = (l-t)/(m-t)
}
REE_S_lcz_MCarlo_samplNoise = sd(rs_boo) 
REE_B_hybr_MCarlo_samplNoise = sd(rh_boo) 
REE_B_static_MCarlo_samplNoise = sd(rv_boo) 

#=======================================
# BANDSPACE stats

# 1) errors

band_Ve_MEs_Mr = apply(bband_Ve_MEs, 2, mean) # mean band_Ve 
band_Ve_AEs_Mr = apply(bband_Ve_AEs, 2, mean) # ave band_Ve MAE over n_repl
band_Vt_Ms_Mr  = apply(bband_Vt_Ms,  2, mean) # mean band_Vt
band_Ve_TD_Msr = apply(bband_Ve_TD_Ms, 2, mean) # mean band_Ve theor SD
band_Ve_TAD_Msr= apply(bband_Ve_TAD_Ms, 2, mean) # mean band_Ve theor MD

nb=nband/1
band_Ve_MEs_Mr_rel_Mb  = mean(band_Ve_MEs_Mr[1:nb])  / mean(band_Vt_Ms_Mr[1:nb]) 
band_Ve_AEs_Mr_rel_Mb  = mean(band_Ve_AEs_Mr[1:nb])  / mean(band_Vt_Ms_Mr[1:nb]) 
band_Ve_TAD_Msr_rel_Mb = mean(band_Ve_TAD_Msr[1:nb]) / mean(band_Vt_Ms_Mr[1:nb]) 

band_V_restored_AEs_Mr = apply(bband_V_restored_AEs, 2, mean)
band_V_restored_MEs_Mr = apply(bband_V_restored_MEs, 2, mean)


mn = min(band_Vt_Ms_Mr, band_Ve_AEs_Mr, band_Ve_MEs_Mr, band_V_restored_AEs_Mr, band_V_restored_MEs_Mr)
mx = max(band_Vt_Ms_Mr, band_Ve_AEs_Mr, band_Ve_MEs_Mr, band_V_restored_AEs_Mr, band_V_restored_MEs_Mr)
namefile=paste0("./Out/BandVeErr_nr", n_repl, "u", crftype, "ne", ne, "kapp", kappa, 
                "NSL", NSL, ".png")
png(namefile, width=7.48, height=5.47, units = "in", res=300)
par(mgp=c(2.5, 1, 0))
plot(band_Vt_Ms_Mr, type="l", xlab = "band", ylab = "Band variances",
     main=paste0(
    "Band variances V: Truth,  Errors (MAE and bias) MAD(Ve) \n",
    " Ensm and Restored from b_LSM \n",
    "u=", crftype, " ne=", ne, " NSL=",NSL, " kappa=", kappa, " nr=", n_repl), 
     sub=paste0(
       "Band-mean relative ensm MAE=", signif(band_Ve_AEs_Mr_rel_Mb,3),
       "  Rel bias=", signif(band_Ve_MEs_Mr_rel_Mb,3)),
     ylim=c(mn,mx), col="black", lwd=2)
lines(band_Ve_AEs_Mr, col="orange", lwd=1.5)
lines(band_Ve_MEs_Mr, col="springgreen4", lwd=1.5)
lines(band_V_restored_AEs_Mr, col="orange", lty=2)
lines(band_V_restored_MEs_Mr, col="springgreen4", lty=2)
lines(band_Ve_TAD_Msr, col="green", lty=3, lwd=3)

abline(h=0, lty=3)
leg.txt<-c('Truth', 'Ensm, MAE', 'Ensm, bias', 'Restored, MAE', 'Restored, bias', 'MAD(Ve)')
leg.col<-c("black", "orange", "springgreen4", "orange", "springgreen4", "green")
legend("topright", inset=0, leg.txt, col=leg.col, 
       lwd=c(2,1.5,1.5,1,1,3), lty=c(1,1,1,2,2,3), pch=c(NA,NA,NA,NA,NA),
       pt.lwd=3, cex=1.3, pt.cex=1, bg="white")
dev.off()


# 2) Misfit of restored band_V with band_Ve

bband_V_restored_misfit_As_Mr = apply(bband_V_restored_misfit_As, 2, mean)
bband_V_restored_misfit_Ms_Mr = apply(bband_V_restored_misfit_Ms, 2, mean)
band_Ve_TAD_Ms_Mr = apply(bband_Ve_TAD_Ms, 2, mean)

mn = min(bband_V_restored_misfit_As_Mr, bband_V_restored_misfit_Ms_Mr, band_Ve_TAD_Ms_Mr, band_Vt_Ms_Mr)
mx = max(bband_V_restored_misfit_As_Mr, bband_V_restored_misfit_Ms_Mr, band_Ve_TAD_Ms_Mr, band_Vt_Ms_Mr)
namefile=paste0("./Out/BandVeMisfit_nr", n_repl, "u", crftype, "ne", ne, "kapp", kappa, 
                "NSL", NSL, ".png")
png(namefile, width=7.48, height=5.47, units = "in", res=300)
par(mgp=c(2.5, 1, 0))
plot(band_Vt_Ms_Mr, type="l", xlab = "Band", ylab = "Error",
     main=paste0(
       "Band vars misfits [V_restored - Ve]: MAD (red), bias (blu) \n",
       "True V (black). Sampling error MD(Ve-V_true) (orng) \n",
       "u=", crftype, "ne=", ne, " NSL=",NSL, " kappa=", kappa, " nr=", n_repl), 
     sub=paste0("NB: Misfit MAE should be comparable to RMS(Ve-V_true)"),
     ylim=c(mn,mx), col="black")
lines(bband_V_restored_misfit_As_Mr, col="red")
lines(bband_V_restored_misfit_Ms_Mr, col="blue")
lines(band_Ve_TAD_Ms_Mr, col="orange")
abline(h=0, lty=3)
dev.off()

#=======================================
# SPECTRAL-SPACE stats (LSM) :  Bias, MAE

b_true_Ms_Mr = apply(bb_true_Ms, 2, mean)
b_LSM_MEs_Mr   = apply(b_LSM_MEs, 2, mean)

b_true_Ms_Mr_Sw = sum(b_true_Ms_Mr)
b_LSM_MEs_Mr_SAw = sum(abs(b_LSM_MEs_Mr))

b_LSM_AEs_Mr = apply(b_LSM_AEs, 2, mean)
b_LSM_AEs_Mr_Sw = sum(b_LSM_AEs_Mr)

b_LSM_AEV_MsMr = mean(b_LSM_AEV_Ms)

nm=nmax/6
mx = max(b_LSM_MEs_Mr[1:nm], b_LSM_AEs_Mr[1:nm], b_true_Ms_Mr[1:nm])
mn = min(b_LSM_MEs_Mr[1:nm], b_LSM_AEs_Mr[1:nm], b_true_Ms_Mr[1:nm])
namefile=paste0("./Out/SpeErr_", "u", crftype, "ne", ne, "nr", n_repl, "kapp", kappa, 
                "NSL", NSL, ".png")
png(namefile, width=7.48, height=5.47, units = "in", res=300)
par(mgp=c(2.5, 1, 0))

plot(b_true_Ms_Mr[1:nm], type="l", ylim=c(mn,mx), col="black", lwd=2,
     main=paste0( "Spectral-space statistics",
                "\n u=", crftype, " ne=", ne, " NSL=",NSL, " kappa=", kappa, " nr=", n_repl ), 
     xlab="n+1", ylab = "Spectral variances",
     sub=paste0( "Total (sum abs): LSM  bias=", signif(b_LSM_MEs_Mr_SAw,3), 
                 "  MAE=", signif(b_LSM_AEs_Mr_Sw,3),
                "   Truth=Var(xi)=", signif(b_true_Ms_Mr_Sw,3) ))
lines(b_LSM_AEs_Mr[1:nm], col="red", lwd=1.5)
lines(b_LSM_MEs_Mr[1:nm], col="red", lty=2, lwd=1.5)

leg.txt<-c('Truth', 'LSM, MAE', "LSM, bias")
leg.col<-c("black", "red", "red")
legend("topright", inset=0, leg.txt, col=leg.col, 
       lwd=c(2,1.5,1.5), lty=c(1,1,2), pch=c(NA,NA,NA),
       pt.lwd=3, cex=1.3, pt.cex=1, bg="white")
abline(h=0, lty=3)
dev.off()

#=======================================
# PHYSICAL-SPACE stats: Correlations: Bias, MAE

aligned_C_Ms_Mr      = apply(aaligned_C_Ms, 2, mean)

aligned_C_LSM_MEs_Mr = apply(aaligned_C_LSM_MEs, 2, mean)
aligned_C_LSM_AEs_Mr = apply(aaligned_C_LSM_AEs, 2, mean)

aligned_CS_lcz_MEs_Mr = apply(aaligned_CS_lcz_MEs, 2, mean)
aligned_CS_lcz_AEs_Mr = apply(aaligned_CS_lcz_AEs, 2, mean)

RelMAE_Diag_LSM = sqrt(mean(RelMSE_Diag_LSM))
RelMAE_Diag_S_lcz = sqrt(mean(RelMSE_Diag_S_lcz))

nonmonot_crl_points_per_i_repl = sum(nn_nmon) / n_repl

# Aligned crfs

nx_mid = round(nx/2)
Dx_align=floor(L_xi_median *10 / dx)
if(Dx_align >= nx/2) Dx_align = floor(nx/2)-1
nx2_align=nx_mid + Dx_align
xx_align = c(0:Dx_align) * dx_km

# CRL Bias & MAE -- averaged over the plotted range of distances 

bias_crl_LSM   = mean(aligned_C_LSM_MEs_Mr[nx_mid:nx2_align])
bias_crl_S_lcz = mean(aligned_CS_lcz_MEs_Mr[nx_mid:nx2_align])

MAE_crl_LSM   = mean(aligned_C_LSM_AEs_Mr[nx_mid:nx2_align])
MAE_crl_S_lcz = mean(aligned_CS_lcz_AEs_Mr[nx_mid:nx2_align])


mn=min(aligned_C_Ms_Mr[nx_mid:nx2_align], aligned_C_LSM_MEs_Mr[nx_mid:nx2_align], aligned_CS_lcz_MEs_Mr[nx_mid:nx2_align])
mx=max(aligned_C_Ms_Mr[nx_mid:nx2_align], aligned_C_LSM_MEs_Mr[nx_mid:nx2_align], aligned_CS_lcz_MEs_Mr[nx_mid:nx2_align])

if(l_CRL_COV_plots == 1){
  namefile=paste0("./Out/CrlErr_", "u", crftype, "_B2S_", B2S_method, "_ne", ne, "nr", n_repl, "kapp", kappa, 
                 "NSL", NSL, ".png")
}else if(l_CRL_COV_plots == 2){
  namefile=paste0("./Out/CovErr_", "u", crftype, "_B2S_", B2S_method, "_ne", ne, "nr", n_repl, "kapp", kappa, 
                  "NSL", NSL, ".png")
}
png(namefile, width=7.48, height=5.47, units = "in", res=300)
par(mgp=c(2.5, 1, 0))

if(l_CRL_COV_plots == 1){
  plot(x=xx_align, 
       y=aligned_C_Ms_Mr[nx_mid:nx2_align], type="l", lwd=2, ylim=c(mn,mx),
       main=paste0("Spatial correlations\n",
                   "u=", crftype, " B2S=", B2S_method, " ne=", ne, " NSL=",NSL, " kappa=", kappa, " nr=", n_repl),
       xlab="Distance, km", ylab="Correlation",
       sub=paste0("Rel variance errors: Bias. LSM: ", signif(mean(RelBias_Diag_LSM),3),
                  "  S_lcz:", signif(mean(RelBias_Diag_S_lcz),3), 
                  ".  MAE. LSM: ",signif(RelMAE_Diag_LSM,3), ".  S_Lcz: ",signif(RelMAE_Diag_S_lcz,3)))
}else if(l_CRL_COV_plots == 2){
  plot(x=xx_align, 
       y=aligned_C_Ms_Mr[nx_mid:nx2_align], type="l", lwd=2, ylim=c(mn,mx),
       main=paste0("Spatial covariances\n",
                   "u=", crftype, " B2S=", B2S_method, " ne=", ne, " NSL=",NSL, " kappa=", kappa, " nr=", n_repl),
       xlab="Distance, km", ylab="Correlation",
       sub=paste0("Rel variance errors: Bias. LSM: ", signif(mean(RelBias_Diag_LSM),3),
                  "  S_lcz:", signif(mean(RelBias_Diag_S_lcz),3), 
                  ".  MAE. LSM: ",signif(RelMAE_Diag_LSM,3), ".  S_Lcz: ",signif(RelMAE_Diag_S_lcz,3)))
}
lines(x=xx_align, y=aligned_C_LSM_AEs_Mr[nx_mid:nx2_align], col="red", lwd=1.5)
lines(x=xx_align, y=aligned_CS_lcz_AEs_Mr[nx_mid:nx2_align], col="blue", lwd=1.5)
lines(x=xx_align, y=aligned_C_LSM_MEs_Mr[nx_mid:nx2_align], col="red", lwd=1.5, lty=2)
lines(x=xx_align, y=aligned_CS_lcz_MEs_Mr[nx_mid:nx2_align], col="blue", lwd=1.5, lty=2)

abline(h=0, lty=3)
leg.txt<-c('Truth', 'LSM, MAE', 'S_lcz, MAE', 'LSM, bias', 'S_lcz, bias')
leg.col<-c("black", "red", "blue", "red", "blue")
legend("topright", inset=0, leg.txt, col=leg.col, 
       lwd=c(2, 1.5, 1.5, 1.5, 1.5), lty=c(1,1,1,2,2), pch=c(NA,NA,NA,NA,NA),
       pt.lwd=3, cex=1.3, pt.cex=1, bg="white")

abline(h=0, lty=3)
dev.off()

#-------------------------------------------------------------------
#-------------------------------------------------------------------

message("Sample MAE(xi_Ve) = ", signif(xi_Ve_AEsr,5), 
        "  Theor MD(xi_Ve) = ", signif(xi_Ve_TAD_Msr,5), 
        " (need be really close in STATIO only)")

message("BANDSPACE: Rel. bias = ", signif(band_Ve_MEs_Mr_rel_Mb,3),
                  "  Rel MAE =",  signif(band_Ve_AEs_Mr_rel_Mb,3),
                  "   Rel theor MAD =",  signif(band_Ve_TAD_Msr_rel_Mb,3))

# if(B2S_method == "SVshape") {
#   message("rel_err_discard_nullspace_b = ",  
#           signif(rel_err_discard_nullspace_b,3))
# }

if(true_spectra_available){
  message("SPE-SPACE: \n LSM:  Bias: ", signif(b_LSM_MEs_Mr_SAw,3),
          "  MAE: ", signif(b_LSM_AEs_Mr_Sw,3),
          "  Truth=", signif(b_true_Ms_Mr_Sw,3),
          "   -- sums over spectrum")
}

message("PHYS-SPACE CRL Bias: \n S_lcz: ", signif(mean(bias_crl_S_lcz),3),
        "  LSM: ", signif(mean(bias_crl_LSM),3))

message("PHYS-SPACE CRL MAE: \n S_lcz: ", signif(mean(MAE_crl_S_lcz),3),
        "  LSM: ", signif(mean(MAE_crl_LSM),3))

message("nonmonot_crl_points_per_i_repl=", nonmonot_crl_points_per_i_repl)

message("PHYS-SPACE Rel Variance Bias: \n S_lcz: ", signif(mean(RelBias_Diag_S_lcz),3),
        "  LSM: ", signif(mean(RelBias_Diag_LSM),3))

message("PHYS-SPACE Vars MAE:  \n S_lcz: ", signif(RelMAE_Diag_S_lcz,3),
        "  LSM: ", signif(RelMAE_Diag_LSM,3))

message("seed=", seed)

# AEV is dA, whr A is the anls err var
# we would like to look at the difference between the LSM based ARMSE
# and the B_true based ARMSE. To do so, we note that
#  d sqrt(A) = 1/(2 sqrt(A)) dA

rel_dARMSE_spec = 1/(2 * anls_RMSE_B_true) * b_LSM_AEV_MsMr / anls_RMSE_B_true

message("SPE-SPACE AEV based dA=", signif(b_LSM_AEV_MsMr / anls_RMSE_B_true^2,2),
        "  dA actual = ", signif(anls_RMSE_B_LSEF^2/anls_RMSE_B_true^2 -1, 2))

fg_evar = mean(ssd_xi_repl^2)
fg_esd = sqrt(fg_evar)

message("Anls RMSE: \nB_LSEF: ", signif(anls_RMSE_B_LSEF,3), 
        "  B_hybr: ", signif(anls_RMSE_B_hybr,3),
        "  B_EnKF: ", signif(anls_RMSE_B_EnKF,3),
        "  B_mean: ", signif(anls_RMSE_B_mean,3),
        "  B_true: ", signif(anls_RMSE_B_true,3),
        "   fg_err_sd: ", signif(fg_esd,3)
)
message("Rel.redu in fg_evar in B_true_anls : ", signif((fg_evar - anls_RMSE_B_true^2)/fg_evar,3))
        
if(kappa > 1 & NSL < 1e3)
  message("   Rh :  diag(A): ",signif(REE_B_hybr,3), 
          "   M-Carlo: ",signif(REE_B_hybr_MCarlo,3))
  message("   Rm :  diag(A): ",signif(REE_B_static,3), 
          "   M-Carlo: ",signif(REE_B_static_MCarlo,3))

if(kappa > 1 & NSL < 1e3 & n_repl > 1)
  message("---SD(Rm):  diag(A):  ",signif(REE_B_static_samplNoise,1), 
          "   M-Carlo: ",signif(REE_B_static_MCarlo_samplNoise,1))

  message("   Rs :  diag(A): ",signif(REE_S_lcz,3), 
          "   M-Carlo: ",signif(REE_S_lcz_MCarlo,3))

if(n_repl > 1) 
  message("---SD(Rs):  diag(A):  ",signif(REE_S_lcz_samplNoise,1), 
          "   M-Carlo: ",signif(REE_S_lcz_MCarlo_samplNoise,1))

# Normalized excess RMSEs
  
message("Anls_RMSE_x/Anls_RMSE_B_true -1:  \nB_LSEF: ", 
          signif(anls_RMSE_B_LSEF/anls_RMSE_B_true -1, 3), 
          "  B_EnKF: ", signif(anls_RMSE_B_EnKF/anls_RMSE_B_true -1, 3),
          "  B_mean: ", signif(anls_RMSE_B_mean/anls_RMSE_B_true -1, 3),
          "  B_hybr: ", signif(anls_RMSE_B_hybr/anls_RMSE_B_true -1, 3))

message("rel_dARMSE = ", signif(anls_RMSE_B_LSEF/anls_RMSE_B_true - 1, 3),
        "   rel_dARMSE_AEV_spec=", signif(rel_dARMSE_spec,2))

